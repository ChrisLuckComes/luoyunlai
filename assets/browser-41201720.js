import{j as e,d as r,e as s}from"./index-d995f4f1.js";import{U as i}from"./useMarkdown-9bb10794.js";import{A as p}from"./Anchor-4feb64ba.js";import{A as l}from"./index-54bf6c12.js";import"./index-fd3e1634.js";import"./pickAttrs-72985405.js";const y="/luoyunlai/assets/share-8364635d.png",f="/luoyunlai/assets/structure-59bc5b2e.webp",T="/luoyunlai/assets/basicFlow-920db518.webp",S="/luoyunlai/assets/mainflow-5301946b.webp",g="/luoyunlai/assets/mathExpression-243bd0f2.webp",k="/luoyunlai/assets/parseTree-8e40b483.webp",N="/luoyunlai/assets/domTree-3d804fcf.webp",w="/luoyunlai/assets/htmlParseingFlow-00a2f5c5.webp",M="/luoyunlai/assets/tokenize-e4be5163.webp",L="/luoyunlai/assets/treeConstruction-ecf386d8.webp",O="/luoyunlai/assets/parseCss-24fcd052.webp",v="/luoyunlai/assets/relation-522b8906.webp",D="/luoyunlai/assets/box-a380c258.webp",C="/luoyunlai/assets/blockBox-2d32eec2.webp",E="/luoyunlai/assets/inlineBox-4878ab02.webp",I="/luoyunlai/assets/blockAndInline-0ee121da.webp",R="/luoyunlai/assets/lines-8b179c7e.webp",H="/luoyunlai/assets/relative-5beca8aa.webp",A="/luoyunlai/assets/float-03777835.webp",_="/luoyunlai/assets/fixed-07792be9.webp",F=`\`\`\` 
comment   /*[^*]**+([^/*][^*]**+)*/
num       [0-9]+|[0-9]*"."[0-9]+
nonascii  [\\200-\\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name      {nmchar}+
ident     {nmstart}{nmchar}*
\`\`\``,W=`\`\`\`
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
\`\`\``,P="```css\ndiv.error, a.error {\n    color:red;\n    font-weight:bold;\n  }\n```",U="```\nruleset\n  : selector [ ',' S* selector ]*\n    '{' S* declaration [ ';' S* declaration ]* '}' S*\n  ;\n```",z=`\`\`\`c++
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
\`\`\``,B=`\`\`\`c++
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
\`\`\``,K="```css\ndiv div div div{\n  ...\n  }\n```",G="```css\np.error {color: red}\n#messageDiv {height: 50px}\ndiv {margin: 5px}\n```",V='```html\n<p class="error">an error occurred</p>\n<div id="messageDiv">this is a message</div>\n```',X='```html\n<div style="width: 30%"/>\n```',J="```C++\nwhile (!mExiting)\n    NS_ProcessNextEvent(thread);\n```",Q='```html\n<p>\n  <img style="float: right" src="images/image.gif" width="100" height="100">\n  Lorem ipsum dolor sit amet, consectetuer...\n</p>\n ```';function se(){const t=e.jsx(i,{markdown:W}),n=e.jsx(i,{markdown:F}),c=e.jsx(i,{markdown:P}),a=e.jsx(i,{markdown:U}),d=e.jsx(i,{markdown:z}),o=e.jsx(i,{markdown:B}),x=e.jsx(i,{markdown:K}),h=e.jsx(i,{markdown:G}),j=e.jsx(i,{markdown:V}),b=e.jsx(i,{markdown:X}),m=e.jsx(i,{markdown:J}),u=e.jsx(i,{markdown:Q});return e.jsxs("article",{id:"rootArticle",className:r.article,children:[e.jsxs("main",{className:r.content,children:[e.jsx("h2",{id:"preface",className:"font-semibold text-h2 mb-2",children:"前言"}),"作为一个web开发者，学习浏览器的内部运行机制能更好的做出决策，同时也可以了解采用最佳实践背后的理由。我们可能经常会被问到，当在地址栏输入完成按下enter键之后都发生了什么，下面会详细说明。",e.jsx("br",{}),e.jsx("h2",{id:"browsers",className:r.articleTitle,children:"有哪些浏览器？"}),"现在PC端主要有5个浏览器：Chrome,IE,Firefox,Safari,Opera。移动端主要是Android Browser,iPhone,Opera Mini,UC browser,Chrome.除了Opera之外，其他所有浏览器都是基于WebKit。截至于2023年，以下是各大浏览器的占有率，数据来源:",e.jsx("a",{className:r.href,target:"_blank",rel:"noreferrer",href:"https://gs.statcounter.com/",children:"StatCounter statistics"}),e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:y}),e.jsx("br",{}),"Chrome可谓是一家独大",e.jsx("h2",{id:"functionality",className:r.articleTitle,children:"浏览器的主要功能"}),"浏览器的主要功能就是从服务器请求网络资源，并且在浏览器窗口显示。资源通常是HTML文档，也有可能是PDF,图片等其他内容。用户用URI(Uniform Resource Identifier)来规定资源路径。浏览器有以下共同UI元素：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 地址栏"}),e.jsx("li",{children:"2. 后退和前进按钮"}),e.jsx("li",{children:"3. 书签"}),e.jsx("li",{children:"4. 刷新和停止"}),e.jsx("li",{children:"5. 首页"})]}),e.jsx("h2",{id:"structure",className:r.articleTitle,children:"浏览器的架构"}),e.jsx("br",{}),e.jsx(s,{src:f}),e.jsx("br",{}),"浏览器的架构如下：",e.jsxs("ul",{children:[e.jsxs("li",{children:["1. ",e.jsx("strong",{children:"用户界面(User Interface)"}),"：包括地址栏，前进后退按钮，书签菜单等。除了页面之外的部分都是。"]}),e.jsxs("li",{children:["2. ",e.jsx("strong",{children:"浏览器引擎(browser engine)"}),"：组织UI和渲染引擎之间的操作"]}),e.jsxs("li",{children:["3. ",e.jsx("strong",{children:"渲染引擎(rendering engine)"}),"：负责展示请求到的内容。如果请求到的内容是HTML，就解析HTML和CSS，将解析后的内容展示出来。 不同的浏览器使用的渲染引擎不同：IE(Trident), Firefox(Gecko), Safari(WebKit), Chrome,Opera(Blink,WebKit分支)。"]}),e.jsxs("li",{children:["4. ",e.jsx("strong",{children:"网络(networking)"}),"：用于网络请求，例如HTTP请求，它有平台无关的接口，对于每个平台有不同的实现。"]}),e.jsxs("li",{children:["5. ",e.jsx("strong",{children:"UI后端(UI backend)"}),"：用于绘制基础部件，例如弹窗和级联选择。它有通用样式，除非使用了操作系统UI。"]}),e.jsxs("li",{children:["6. ",e.jsx("strong",{children:"JS解释器(JavaScript interpreter)"}),"：用于解析和执行js代码"]}),e.jsxs("li",{children:["7. ",e.jsx("strong",{children:"数据存储(Data storage)"}),"：它是持久层。浏览器可能需要本地保存各种类型的数据，例如cookies。浏览器也支持localStorage,IndexedDB,WebSQL,FileSystem等存储机制。"]})]}),"值得一提的是，像Chrome这种浏览器的渲染引擎会运行多个实例，每个实例对应每个tab。每个tab都是独立进程。",e.jsx("h2",{id:"mainFlow",className:r.articleTitle,children:"主要流程"}),"渲染引擎从网络层获取请求到的文档，之后，开始如下的渲染流程。",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:T}),e.jsx("br",{}),"渲染引擎开始解析HTML文档，把元素转换为DOM树(content tree)。引擎还会解析样式数据，包括外部CSS文件和style元素。样式信息和HTML中的视觉描述一起创建渲染树(render tree)",e.jsx("br",{}),e.jsx("br",{}),"渲染树包含了有颜色、尺寸等视觉属性的矩形，它们会以正确的顺序显示在屏幕上。",e.jsx("br",{}),e.jsx("br",{}),"渲染树构建完后，开始布局(layout)进程，就是给每一个节点精确的坐标，让它们显示在应该出现的位置。下一步就是绘制，使用UI后端(UI backend)层遍历渲染树绘制每个节点。",e.jsx("br",{}),e.jsx("br",{}),"以上是一个渐进的过程，为了更好的用户体验，渲染引擎会尽快显示内容。在开始构建和布局渲染树之前，它不会等到HTML全部解析完才开始显示。部分内容会先被解析后显示，同时进程也在继续处理从网络层来的剩余内容。",e.jsx("h3",{id:"examples",className:r.articleSubTitle,children:"主要流程案例"}),e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:S}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h3",{id:"parse",className:r.articleSubTitle,children:"解析"}),"解析就是把文档转换成代码可以使用的结构，转换的结果通常是节点树，代表了文档的结构，也被称为语法树。如下图：",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:g}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h3",{id:"parser",className:r.articleSubTitle,children:"词法分析和语法分析"}),"解析分为两个子进程，词法分析(lexer)和语法分析(parser)。",e.jsx("br",{}),e.jsx("br",{}),"词法分析就是把输入分割为单词的过程，它们都是来自语法词汇表中，就像人类语言都是由词典中的单词组成一样。它会移除不相关的内容例如空格和换行。",e.jsx("br",{}),e.jsx("br",{}),"语法分析就是语法规则的应用。它根据语法规则分析文档结构创建语法树。",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:k}),e.jsx("br",{}),"分析是循环的过程。语法分析器向词法分析器请求单词并和语法规则匹配，如果匹配成功就在语法树上新增一个节点，然后再请求下一个单词。",e.jsx("br",{}),"如果匹配失败，语法分析器先保存单词，继续请求单词直到内部保存的单词被匹配上为止。如果没有找到规则语法分析器会抛出异常，说明文档无效，包含语法错误。",e.jsx("h3",{id:"parsingExample",className:r.articleSubTitle,children:"解释案例"}),"我们来定义一个模型来模拟分析过程，语法如下：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 语法块可以是单词，表达式和运算"}),e.jsx("li",{children:"2. 语言可以包含任意数字"}),e.jsx("li",{children:"3. 一个表达式后跟随运算再跟随另一个表达式"}),e.jsx("li",{children:"4. 运算是加法符号和减法符号"}),e.jsx("li",{children:"5. 表达式是数字或单词"})]}),"举个栗子,分析一下",e.jsx("code",{children:"2 + 3 - 1"}),"：",e.jsx("br",{}),e.jsx("br",{}),"首个命中规则的字串是",e.jsx("code",{children:"2"}),"，第5条。第二个命中的是",e.jsx("code",{children:"2 + 3"}),"，第3条。最后",e.jsx("code",{children:"2 + 3 - 1"}),"再次命中第3条，因为",e.jsx("code",{children:"2 + 3"}),"是一个表达式",e.jsx("h3",{id:"formal",className:r.articleSubTitle,children:"词汇表和语法的正式定义"}),"还是上面的模型，词汇表定义如下:",e.jsx("br",{}),e.jsx("br",{}),e.jsx(l,{type:"info",message:e.jsxs("div",{children:[e.jsx("div",{children:"INTEGER: 0|[1-9][0-9]*"}),e.jsx("div",{children:"PLUS: +"}),e.jsx("div",{children:"MINUS: -"})]})}),e.jsx("br",{}),e.jsx("br",{}),"数字被定义成正则表达式。语法通常被定义为巴科斯范式(Backus–Naur form)，如下：",e.jsx("br",{}),e.jsx("br",{}),e.jsx(l,{type:"info",message:e.jsxs("div",{children:[e.jsx("div",{children:"expression := term operation term"}),e.jsx("div",{children:"operation := PLUS | MINUS"}),e.jsx("div",{children:"term := INTEGER | expression"})]})}),e.jsx("br",{}),e.jsx("br",{}),"如果语法是上下文无关的话，语言就可以被规范解释器解析。上下文无关语法(",e.jsx("a",{className:r.href,target:"_blank",rel:"noreferrer",href:"https://en.wikipedia.org/wiki/Context-free_grammar",children:"Context-free grammar"}),")就是可以完全用BNF表示的语法",e.jsx("h3",{id:"parseType",className:r.articleSubTitle,children:"解释器的类型"}),e.jsx("br",{}),e.jsx("br",{}),"有两种类型的解释器，自顶向下和自底向上。自顶向下检查语法的高级别结构并匹配规则，自底向上从输入开始逐步按语法规则转换，从低级别规则开始到高级别规则。 还是上面的栗子",e.jsx("code",{}),"：",e.jsx("br",{}),e.jsx("br",{}),"自顶向下从高级别规则开始，首先会识别出",e.jsx("code",{children:"2 + 3"}),"作为表达式，然后再识别",e.jsx("code",{children:"2 + 3 - 1"}),"作为表达式。",e.jsx("br",{}),"自底向上会扫描输入直到匹配规则成功。",e.jsx("h2",{id:"htmlParser",className:r.articleTitle,children:"HTML解析"}),"HTML语法由W3C organization定义,虽然它有正式的格式定义DTD(Document Type Definition)，但它不是上下文无关语法。HTML解释器就是把HTML标记转换为语法树。",e.jsx("br",{}),e.jsx("br",{}),e.jsx("h3",{id:"dtd",className:r.articleSubTitle,children:"HTML DTD"}),"DTD用来定义",e.jsx("a",{className:r.href,target:"_blank",rel:"noreferrer",href:"https://zh.wikipedia.org/wiki/SGML",children:"SGML(Standard Generalized Markup Language)"}),"家族的语言(XML,HTML),它包括了允许的元素定义，属性和层次。",e.jsx("br",{}),"DTD有一些变种。严格模式只符合定义，但是其他模式包括对以前浏览器使用过标记的支持。目的主要是向后兼容旧内容。",e.jsx("h3",{id:"dom",className:r.articleSubTitle,children:"dom"}),"语法树由DOM(Document Object Modal)元素和属性节点组成，DOM大多数是一对一的标记。",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:N}),e.jsx("br",{}),e.jsx("br",{}),"跟HTML类似，DOM也是W3C组织定义的，地址如下：",e.jsx("a",{className:r.href,target:"_blank",rel:"noreferrer",href:"http://www.w3.org/DOM/DOMTR",children:"http://www.w3.org/DOM/DOMTR"}),e.jsx("h3",{id:"algo",className:r.articleSubTitle,children:"解析算法"}),"HTML因为种种原因不能用规范的解析技术，浏览器自定义了解释器来解析HTML。算法主要包括两个阶段：词语切分和树的构建。",e.jsx("br",{}),"词语切分就是词法分析，将输入解析为标记，标记的范围是开始tag,结束tag，属性名和属性值。切分器识别到了标记，把它给到树的构造器，然后使用下一个字母来识别下一个标记，直到结束。",e.jsx(s,{src:w}),e.jsx("h3",{id:"tokenizationAlgo",className:r.articleSubTitle,children:"切分算法"}),"算法的输出是HTML token。算法被表示为状态机，每个状态消费输入流的一个或多个字母，并且更新下一个状态，它会被当前的切分状态和树的构建状态影响，这个算法很复杂，举个栗子。",e.jsx(l,{type:"info",message:e.jsxs("div",{children:[e.jsx("div",{children:"<html>"}),e.jsxs("div",{children:[" ","    <body>Hello World</body>"]}),e.jsx("div",{children:"</html>"})]})}),e.jsx("br",{}),e.jsx("br",{}),'初始状态称为"data state"。当遇到',e.jsx("code",{children:"<"}),'时，状态变为"Tag open state"。消费',e.jsx("code",{children:"a-z"}),'字母时创建"Start tag token"，状态变为"Tag name state"。然后保持这个state直到',e.jsx("code",{children:">"}),"被消费。每个字母会被追加到token name上。上面的栗子被创建的token就是",e.jsx("code",{children:"html"})," token。",e.jsx("br",{}),e.jsx("br",{}),"当遇到",e.jsx("code",{children:">"}),'时,当前token被发出，状态变为"Data state"，然后用同样的步骤对待',e.jsx("code",{children:"<body>"})," tag，到现在已经发出了",e.jsx("code",{children:"html"}),"和",e.jsx("code",{children:"body"}),' tag，状态又回到了"Data state" 开始消费H字母时会创建并发出一个字母token，直到遇到body标记的',e.jsx("code",{children:"<"}),"，最后发出一个字母token包括",e.jsx("code",{children:"Hello world"}),"的每个字母。",e.jsx("br",{}),e.jsx("br",{}),'再回到"Tag open state"。开始消费',e.jsx("code",{children:"/"}),"符号时会创建",e.jsx("code",{children:"end tag token"}),'，状态变为"Tag name state"，保持这个state直到',e.jsx("code",{children:">"}),'，就又发出了一个新的tag token，状态变为"Data state"，',e.jsx("div",{className:"code",children:"</html>"}),"的处理也跟之前一样。",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:M}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h3",{id:"treeAlgo",className:r.articleSubTitle,children:"树的构建算法"}),'第一个mode是"initial mode"，接收',e.jsx("code",{children:"html"}),'token会触发"before html"mode，创建HTMLHtmlElement element，然后追加到根节点上。',e.jsx("br",{}),'然后状态变为"before head"，接收到body token。然后隐式创建HTMLHeadElement并添加到树，尽管没有head token。',e.jsx("br",{}),'接着状态变为"in head"，然后再是"after head"，重新处理body token，创建并插入HTMLBodyElement，状态随后变为"in body"',e.jsx("br",{}),'接收到Hello world字符token，第一个字符会触发创建"Text"节点，剩余的字母会追加到该节点。',e.jsx("br",{}),'body end token的接收，状态变为"After body" mode。',e.jsx("br",{}),'接收到html end tag进入"after after body" mode。',e.jsx("br",{}),"接收到文件结尾就停止解析。",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:L}),e.jsx("h3",{id:"parseFinished",className:r.articleSubTitle,children:"解析完成后的操作"}),"这个阶段浏览器会标记文档为可交互状态，开始解析",e.jsx("strong",{children:"deferred"}),"的脚本，这些脚本应该在文档解析完成后执行。然后文档状态会被设置为",e.jsx("strong",{children:"complete"}),"，",e.jsx("strong",{children:"load"}),"事件会开始执行。",e.jsx("br",{}),e.jsx("br",{}),e.jsx("a",{className:r.href,target:"_blank",rel:"noreferrer",href:"https://html.spec.whatwg.org/multipage/syntax.html#html-parser",children:"解析的完整过程在这儿"}),e.jsx("h2",{id:"cssParser",className:r.articleTitle,children:"CSS解析"}),"CSS是上下文无关语法，可以被解释器解析。举个栗子：",e.jsx("br",{}),"规范表达式词法如下：",n,e.jsx("strong",{children:"ident"}),"是identifier的缩写，就像classname。",e.jsx("strong",{children:"name"}),"就是元素id",e.jsx("br",{}),"语法BNF描述如下：",t,e.jsx("br",{}),"一个规则集就是如下这种结构",c,e.jsx("br",{}),e.jsx("code",{children:"div.error"}),"和",e.jsx("code",{children:"a.error"}),"是选择器，大括号内部包含了应用到该选择器的规则，这个结构命中了如下规则定义",a,e.jsx("br",{}),"规则描述：一个或多个选择器，可以用空格(S*表示逗号)和逗号分割。规则集由大括号和内部的一个或多个用分号隔开的描述组成。",e.jsx("br",{}),e.jsx("br",{}),e.jsx(s,{src:O}),e.jsx("h2",{id:"order",className:r.articleTitle,children:"加载script和css的顺序"}),e.jsx("h3",{id:"scripts",className:r.articleSubTitle,children:"Scripts"}),"web的模型是同步的，作者希望解释器遇到",e.jsx("code",{children:"script"}),"标签时立即解析和执行scripts，此时文档的解析会暂停直到script执行完成。 如果这个script是外部的，资源首先要通过网络请求回来，这也是同步的，解析会暂停直到资源取回完成再开始。开发者可以在script上加上",e.jsx("strong",{children:"defer"}),"属性，它就不会暂停文档解析，会在文档解析完后再执行。HTML5新增了",e.jsx("strong",{children:"async"}),"异步属性，它会在另一个线程解析和执行。",e.jsx("h3",{id:"speculative",className:r.articleSubTitle,children:"预测解析"}),"WebKit和Firefox都做了这项优化。当执行script时，另一个线程解析剩下的文档并找出其他需要被加载的网络资源并加载它们。这样资源可以并行的连接上加载，总体速度提升。",e.jsx("br",{}),"值得一提的是，这个预测只解析外部引用资源例如外部script，样式表和图片，它不修改DOM Tree。",e.jsx("h3",{id:"styleSheet",className:r.articleSubTitle,children:"样式表"}),"样式表有另一个模型。概念上样式表不改变DOM tree，没理由去等它们，但是样式没有加载和解析的话，会引起很多问题。所以Firefox引擎的优化方式是，在样式表加载和解析的时候，停止scripts。而WebKit只允许scipts访问会影响没有加载的样式表的属性",e.jsx("h2",{id:"renderTree",className:r.articleTitle,children:"Render Tree的构建"}),"当DOM tree创建完成时，浏览器创建另一颗树，render tree，它由要展示的元素按顺序组成，目的是为了按顺序渲染内容。",e.jsx("br",{}),"Firefox称render tree中这些元素为",e.jsx("strong",{children:"frame"}),"，WebKit则称为renderer或render object",e.jsx("br",{}),"renderer知道怎么去布局和渲染它自己和它的children，如下是WebKit的RenderObject类定义，它是renderer的父类",d,"每个renderer代表一个矩形区域，对应css的盒子。它包括了几何图形的信息例如宽度，高度和位置。",e.jsx("br",{}),"盒子类型被",e.jsx("strong",{children:"display"}),"样式属性值影响。以下是WebKit中判断display属性值来决定创建DOM节点的renderer类型的代码",o,"元素类型也是考虑在内的，form和table有特殊处理。在WebKit如果元素想新增特殊renderer，会重写",e.jsx("code",{children:"createRenderer"}),"方法。",e.jsx("h3",{id:"renderTreeRelate",className:r.articleSubTitle,children:"Render tree和DOM tree的关系"}),"虽然renderers和DOM元素一致,但是不是一对一的关系。不可见的DOM元素不会被插入render tree，例如head。 display值为",e.jsx("strong",{children:"none"}),"也不会出现在树中(然而visibility:hidden会)。",e.jsx("br",{}),"有的DOM元素跟多个object关联，因为它们的结构复杂，单个矩形描述不了。例如",e.jsx("code",{children:"select"}),"元素有三个renderer，一个用于展示区域，一个用于下拉列表盒子，一个用于按钮。 文本宽度一行不足被强制换行的时候，新行也会新增额外的renderer。",e.jsx("br",{}),"有些render objects跟DOM节点对应的位置不一样。Floats和绝对定位元素是脱离文档流的，放置在树的不同位置，定位在实际占位的地方。",e.jsx("br",{}),e.jsx(s,{src:v}),e.jsx("br",{}),e.jsx("br",{}),"在WebKit解决样式，创建renderer的进程名为",e.jsx("code",{children:"attachment"}),"，每个DOM节点都有",e.jsx("code",{children:"attach"}),"方法。Attachment是同步的，节点插入DOM tree时会调用新节点的attach方法。",e.jsx("br",{}),"根节点对应CSS标准的containing block，最顶部的块包括所有其他块。它的尺寸就是视口，也就是浏览器窗口展示区域尺寸，WebKit称为",e.jsx("code",{children:"RenderView"}),"。 这就是document指向的render object，树中剩余节点都会当作DOM节点创建并插入。",e.jsx("h3",{id:"styleComputation",className:r.articleSubTitle,children:"样式计算"}),"构建render tree需要计算每个render object的可视属性，这需要计算每个元素的样式属性。",e.jsx("br",{}),"样式包括不同来源的样式表，行内样式和HTML的可视属性(例如",e.jsx("code",{children:"bgcolor"}),"属性)，后面会被转换称对应的CSS样式属性。",e.jsx("br",{}),"样式表的来源有浏览器默认样式表，开发者提供的样式表，还有用户样式表。",e.jsx("br",{}),"样式计算有如下难题：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 样式数据结构很庞大，保持这么庞杂的样式属性，会造成内存问题"}),e.jsxs("li",{children:["2. 如果没有优化的话，给每一个元素寻找对应的规则会造成性能问题。对每个元素遍历整个规则列表去匹配是一个很重的任务。结构复杂的选择器会造成多次匹配",e.jsx("br",{}),"就像如下的复合规则:",e.jsx("br",{}),x,e.jsx("br",{}),"这个规则表示div是3个div的子节点。设想一下，如果要检查这个规则是否符合给定的div元素，从头开始遍历节点树，只有1到2个div的不符合规则，又需要重新开始找。"]}),e.jsx("li",{children:"定义规则层次时包括很复杂规则，例如级联。下面看下浏览器怎么面对这些问题。"})]}),e.jsx("h3",{id:"share",className:r.articleSubTitle,children:"共享样式数据"}),"WebKit节点引用style objects(RenderStyle)，这些对象可以在某些情况下在节点间共享，这些节点是兄弟姐妹节点且满足如下条件：",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"元素必须都在同一个鼠标状态下"}),e.jsx("li",{children:"元素都不应该有id"}),e.jsx("li",{children:"标签名应该匹配"}),e.jsx("li",{children:"class属性值应该匹配"}),e.jsx("li",{children:"样式属性必须完全一样"}),e.jsx("li",{children:"链接状态必须匹配"}),e.jsx("li",{children:"focus状态必须匹配"}),e.jsx("li",{children:"元素都不能被属性选择器影响"}),e.jsx("li",{children:"不能有行内样式"}),e.jsx("li",{children:"不能有兄弟选择器，包括+选择器，:first-child，last-child这种"})]}),e.jsx("h3",{id:"division",className:r.articleSubTitle,children:"分割为结构体"}),"样式上下文被分割为多个结构体。这些结构体包含某个具体的样式类型信息，例如border和color。所有结构体中的属性要么是继承的要么不是，继承的属性除非是自己定义的不然就是继承自父级，非继承的属性(reset)如果没有定义则使用默认值。",e.jsx("h3",{id:"manipulate",className:r.articleSubTitle,children:"简单匹配的操作"}),"有如下来源的样式：",e.jsx("br",{}),e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:["CSS规则，在style元素中或在外部样式表中：","p {color:blue}"]}),e.jsxs("li",{children:["行内样式",'<p style="color:blue"></p>']}),e.jsxs("li",{children:["HTML可视属性",'<p bgcolor="blue"></p>']})]}),"后面两个很容易匹配到元素，因为它有样式属性和HTML属性可以用作key。",e.jsx("br",{}),"在解析完样式表后，规则通过选择器加入一些hash map中。有以id,classname,tagname作key的map，也有通用的map。比如，如果选择器是id，或者class，那么这些样式会被加入到对应的map，以此类推。",e.jsx("br",{}),"这个操作让匹配元素变得更简单，不需要再去找每一个声明，将相关的规则提取。",e.jsx("br",{}),"举个栗子：",h,"第一个规则会插入class map，第二个插入id map,第三个插入tag map。 对于下面的文档碎片：",j,e.jsx("br",{}),e.jsx("br",{}),"首先看p元素，它有class属性且值为error，所以在class map中p.error规则匹配上了。再看div，因为它有id，同理也是匹配上了id map。 所以工作变得很简单，只需要在元素匹配的map中去匹配。",e.jsx("br",{}),"WebKit和Firefox都做了这个操作。",e.jsx("h3",{id:"cascade",className:r.articleSubTitle,children:"样式表的顺序"}),"如果属性没有被任何规则定义，那么就会继承一些父级元素的样式，有些属性有默认值。那么问题来了，如果有不止一个定义怎么办呢？",e.jsx("br",{}),"样式表的顺序如下(从低到高)：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 浏览器声明"}),e.jsx("li",{children:"2. 用户通常声明"}),e.jsx("li",{children:"3. 作者通常声明"}),e.jsx("li",{children:"4. 作者important声明"}),e.jsx("li",{children:"5. 用户important声明"})]}),e.jsx("br",{}),e.jsx("br",{}),"如果声明在同一级别，那么就会按定义的顺序来，详见下文"," ",e.jsx("a",{className:r.href,target:"_self",rel:"noreferrer",href:"#specificity",children:"明确定义"}),"。",e.jsx("h3",{id:"specificity",className:r.articleSubTitle,children:"明确定义"}),e.jsxs("ul",{children:[e.jsxs("li",{children:["1. 如果声明来自",e.jsx("code",{children:"style"}),"属性而不是选择器，+1，否则+0 (=a)"]}),e.jsx("li",{children:"2. id选择器+1 (=b)"}),e.jsx("li",{children:"3. 其他选择器和伪类+1 (=c)"}),e.jsx("li",{children:"4. 标签名选择器和伪元素+1 (=d)"})]}),"将a-b-c-d四个数值连在一起，然后排序。",e.jsx("br",{}),e.jsx("br",{}),e.jsx("h2",{id:"layout",className:r.articleTitle,children:"布局"}),"当renderer创建完成后，它并没有位置和大小，计算它们的过程称为布局或者回流(reflow)。",e.jsx("br",{}),"HTML在layout model的基础上使用flow，代表大多数时间都可能在单次计算出几何属性。当前flow元素通常不会影响之前flow中的元素的几何属性，所以文档布局可以从左到右，从上到下执行。例外情况：例如HTML",e.jsx("code",{children:"table"}),"元素可能不止一次计算。",e.jsx("br",{}),"坐标系统和根部框架相关，使用top和left坐标轴。",e.jsx("br",{}),"布局是一个递归的过程。它从根节点开始，对应的就是HTML文档的",e.jsx("code",{children:"html"}),"元素，然后层级递归地给每一个renderer计算几何属性。",e.jsx("br",{}),"根节点的renderer位置是0,0，它的尺寸就是视口viewport，也就是浏览器窗口的可视部分",e.jsx("br",{}),"所有的renderer都有",e.jsx("code",{children:"layout"}),"，",e.jsx("code",{children:"reflow"}),"方法，每个renderer给它需要layout的子节点唤起",e.jsx("code",{children:"layout"}),"方法。",e.jsx("h3",{id:"dirtyBit",className:r.articleSubTitle,children:"标志位系统"}),"为了避免一个小小的改变就完整layout，浏览器使用了标志位系统",e.jsx("code",{children:"dirty bit system"}),"。有变化的或者新增的renderer，将它自己和子节点标记为",e.jsx("code",{children:"dirty"}),": 需要layout。",e.jsx("br",{}),"有两个flag,",e.jsx("code",{children:"dirty"}),"和",e.jsx("code",{children:"children are dirty"}),"表示至少有一个子节点需要layout。",e.jsx("h3",{id:"global",className:r.articleSubTitle,children:"全局和增量的布局"}),"Layout可以发生在整个render树上，这是全局layout。它的发生可能有如下原因：",e.jsxs("ul",{children:[e.jsxs("li",{children:["1. 全局样式改变影响到了所有的renderer，例如",e.jsx("code",{children:"fontSize"}),"变化"]}),e.jsx("li",{children:"2. 作为屏幕改变了大小的结果"})]}),e.jsx("br",{}),"layout可以是增量的，仅当标记为",e.jsx("strong",{children:"dirty"}),"的renderer要被展示的时候。例如从网络来的新的内容被添加到DOM Tree后，新的renderer追加到render tree中，就会异步触发增量layout。",e.jsx("h3",{id:"async",className:r.articleSubTitle,children:"异步和同步layout"}),"增量layout是异步完成的。WebKit有定时器来执行增量layout。",e.jsx("br",{}),"脚本请求例如",e.jsx("code",{children:"offsetHeight"}),"这种样式属性可以触发异步的增量layout。",e.jsx("br",{}),"全局layout通常都会异步触发。",e.jsx("br",{}),"有时候因为某些属性，在初始layout之后，layout作为回调函数触发，例如滚动位置的变化。",e.jsx("h3",{id:"optimization",className:r.articleSubTitle,children:"优化"}),"当layout在渲染位置的时候，被",e.jsx("code",{children:"resize"}),"等事件触发，这些renders的大小会从缓存中获取，不会重新计算。",e.jsx("br",{}),"有些情况子树被修改了，layout也不会从root开始。例如文字被插入文字区域这种，修改只在它自身，不会影响周围。",e.jsx("h3",{id:"layoutProcess",className:r.articleSubTitle,children:"布局过程"}),"layout通常有以下几种模式：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 父级renderer决定它的宽度"}),e.jsxs("li",{children:["2. 父级检查子级",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"替换子renderer(重新设置x和y)"}),e.jsx("li",{children:"如果有必要，会调用子级的layout - 在被标记为dirty或者在全局layout，或者需要计算子级的高度的情况下"})]})]}),e.jsx("li",{children:"父级用子级累加高度，还有margin和padding来设置自己高度的情况下，layout会被父级使用。"}),e.jsx("li",{children:"设置自身的dirty为false时"})]}),e.jsx("h3",{id:"widthCalculation",className:r.articleSubTitle,children:"宽度计算"}),"renderer的宽度使用容器的宽度计算，包括",e.jsx("strong",{children:"width,margin,border"}),"等属性。",e.jsx("br",{}),"例如以下的div",b,"WebKit按如下规则计算：",e.jsx("ul",{className:r.ul,children:e.jsxs("li",{children:["容器宽度是所有容器的",e.jsx("code",{children:"availableWidth"}),"和0之中的最大值。这个栗子中",e.jsx("code",{children:"availableWidth"}),"就是",e.jsx("code",{children:"contentWidth"}),"计算方式如下",e.jsx("div",{className:"markdown-container",children:"clientWidth() - paddingLeft() - paddingRight()"})]})}),e.jsx("code",{children:"clientWidth"}),"和",e.jsx("code",{children:"clientHeight"}),"代表对象内部的宽高，也就是说不包括",e.jsx("code",{children:"border"}),"和",e.jsx("code",{children:"scrollbar"}),e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:["元素宽度是",e.jsx("code",{children:"width"}),"属性时，它会被当作绝对值来计算容器宽度的百分比"]}),e.jsxs("li",{children:["水平的",e.jsx("code",{children:"border"}),"和",e.jsx("code",{children:"padding"}),"被添加了"]})]}),"到目前为止是优先宽度的计算，下面介绍最小和最大的宽度计算。",e.jsx("br",{}),"如果优先宽度大于最大宽度，那么使用最大宽度。如果比最小宽度还小，那就使用最小宽度。",e.jsx("h3",{id:"line",className:r.articleSubTitle,children:"换行"}),"当renderer在布局中途决定需要换行，renderer就会停止并通知父级当前renderer需要被破坏，然后父级就会创建额外的renderer并调用layout。",e.jsx("h2",{id:"painting",className:r.articleTitle,children:"渲染"}),"在渲染阶段，遍历render tree调用每个renderer的",e.jsx("code",{children:"paint"}),"方法来把内容展示到屏幕上。渲染使用UI基础组件。",e.jsx("h3",{id:"globalAndIncremental",className:r.articleSubTitle,children:"全局和增量"}),"和layout一样，渲染也可以是全局和增量的。增量渲染时，有些renderer的改变不影响整个tree。修改后的renderer使矩形失效了，它会让操作系统识别到它是一个",e.jsx("strong",{children:"dirty"}),"区域然后生成",e.jsx("code",{children:"paint"}),"事件。操作系统会将多个区域合并为一个。在Chrome中，它的操作更为复杂，展示过程中监听这些事件并且委托消息给根节点，遍历树直到找到相关的renderer，它会重新渲染自身。",e.jsx("h3",{id:"paintingOrder",className:r.articleSubTitle,children:"渲染顺序"}),"CSS标准定义了渲染顺序，它实际上是元素在堆叠上下文中的顺序。堆叠上下文从后往前渲染，它的顺序如下：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. background color"}),e.jsx("li",{children:"2. background image"}),e.jsx("li",{children:"3. border"}),e.jsx("li",{children:"4. children"}),e.jsx("li",{children:"5. outline"})]}),e.jsx("h3",{id:"dynamicChanges",className:r.articleSubTitle,children:"动态修改"}),"浏览器会尽量做最小的动作来响应修改，所以对于元素颜色的修改只会重新绘制它本身，但是对于位置的修改会触发layout，它自身，它的子集，可能还有兄弟节点都会重绘。",e.jsx("br",{}),"新增DOM节点也跟上面一样。",e.jsx("br",{}),"像修改",e.jsx("code",{children:"html"}),"元素的",e.jsx("code",{children:"fontSize"}),"这种大的操作，会引起缓存失效，重新布局和绘制整个树。",e.jsx("h3",{id:"thread",className:r.articleSubTitle,children:"渲染引擎线程"}),"除了网络操作，基本上都是单线程的，包括渲染引擎。在Firefox和Safari中，渲染引擎是主线程，在Chrome中是当前tab进程的主线程。",e.jsx("br",{}),"网络操作可以多线程并行执行，并行连接的数量浏览器做了限制，一般是2-6，Chrome就是6。",e.jsx("h3",{id:"eventLoop",className:r.articleSubTitle,children:"事件循环"}),"浏览器主线程是事件循环。它是一个保持进程活跃的无限循环，它等待事件并执行它们，代码如下：",m,e.jsx("h2",{id:"cssVisualModel",className:r.articleTitle,children:"CSS视觉模型"}),e.jsx("h3",{id:"canvas",className:r.articleSubTitle,children:"Canvas"}),"canvas是一个空间，浏览器将内容绘制到这个空间，生成格式化的结构。",e.jsx("h3",{id:"box",className:r.articleSubTitle,children:"CSS盒模型"}),e.jsx("a",{className:r.href,target:"_blank",rel:"noreferrer",href:"http://www.w3.org/TR/CSS2/box.html",children:"CSS盒模型"}),"：视觉格式化模型，它用于在文档树中生成并展示元素。",e.jsx("br",{}),"每个盒子都有内容区域(文字，图片等)和周围的padding,border,margin区域。",e.jsx(s,{src:D}),e.jsx("br",{}),e.jsx("br",{}),"所有的元素都有",e.jsx("code",{children:"display"}),"属性，它决定生成什么类型的盒子。",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"block: 生成block box"}),e.jsx("li",{children:"inline: 生成一个或多个inline boxes"}),e.jsx("li",{children:"none: 不会生成"})]}),e.jsx("br",{}),"默认类型是inline，但是浏览器的样式表会设置其他默认值,例如",e.jsx("code",{children:"div"}),"元素的默认值是block。",e.jsx("h3",{id:"position",className:r.articleSubTitle,children:"位置方案"}),"有三种方案：",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"Normal: 对象通过它在文档中的位置来定位，它会通过box类型和尺寸来显示。"}),e.jsx("li",{children:"Float: 首先会像正常流一样显示，然后会尽量向左或向右移动。"}),e.jsx("li",{children:"Absolute: 对象在渲染树的位置和在DOM树的位置不同。"})]}),"这些方案都使用",e.jsx("code",{children:"position"}),"和",e.jsx("code",{children:"float"}),"属性来设置。",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"static和relative是正常文档流"}),e.jsx("li",{children:"absolute和fixed是绝对定位"})]}),"static表示使用默认position，其他的方案使用top,bottom,left,right来定位。",e.jsx("br",{}),"box展示方式由如下内容决定：",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"盒子类型"}),e.jsx("li",{children:"盒子位置"}),e.jsx("li",{children:"定位方案"}),e.jsx("li",{children:"像图片大小和屏幕大小这种外部信息"})]}),e.jsx("h3",{id:"boxType",className:r.articleSubTitle,children:"盒子类型"}),e.jsx("strong",{children:"block"}),": 由一个block形成，在浏览器窗体内有自己的矩形",e.jsx(s,{src:C}),e.jsx("br",{}),e.jsx("strong",{children:"inline"}),": 没有自己的block，被block包含",e.jsx(s,{src:E}),e.jsx("br",{}),"block盒子在垂直方向排列，inline的盒子则是水平排列。",e.jsx(s,{src:I}),e.jsx("br",{}),"inline盒子放在",e.jsx("strong",{children:"line boxes"}),"行盒子内。行盒子至少和最高的盒子一样高，也可以更高。当盒子按",e.jsx("strong",{children:"baseline"}),"方式对齐，代表元素底部对齐其他盒子的底部。",e.jsx("br",{}),e.jsx(s,{src:R}),e.jsx("h3",{id:"positioning",className:r.articleSubTitle,children:"定位"}),e.jsx("strong",{children:"relative"}),e.jsx("br",{}),"相对定位：定位和平常一样，然后按规定数值移动",e.jsx(s,{src:H}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("strong",{children:"float"}),e.jsx("br",{}),"float盒子会漂移到行的左边或者右边，有趣的是其他的盒子围在它的周围。",u,"显示如下：",e.jsx(s,{src:A}),e.jsx("br",{}),e.jsx("strong",{children:"absolute和fixed"}),e.jsx("br",{}),"元素不参与正常文档流，它们相对父容器来定位。fixed的父容器是viewport。",e.jsx(s,{src:_}),e.jsx(l,{type:"info",message:"fixed元素不会随着文档滚动而移动。"}),e.jsx("h3",{id:"layer",className:r.articleSubTitle,children:"层级展示"}),"层级由",e.jsx("code",{children:"z-index"}),"属性定义，它代表盒子的三维，也就是z轴的位置。",e.jsx("br",{}),"盒子被分成层级上下文。每层后面的元素会先渲染然后前面的元素在顶部，更靠近用户。在重叠的情况下，最前面的元素会遮住后面的元素。",e.jsx("br",{}),"层级通过",e.jsx("code",{children:"z-index"}),"属性来排序。当元素没有包含z-index时，排序规则如下（由底到顶）：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 根元素的背景和边界"}),e.jsx("li",{children:"2. 普通流的块元素，按HTML中的出现顺序堆叠"}),e.jsx("li",{children:"3. 定位元素按HTML中出现的顺序堆叠"})]}),e.jsx(l,{type:"info",message:e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"在一组不含有z-index的同类元素，这些元素按HTML出现的顺序堆叠，不管定位属性如何"}),e.jsx("li",{children:"普通流中不含定位属性的块元素始终先于定位元素渲染并出现在定位元素的下层，即使出现顺序晚于定位元素。"})]})})]}),e.jsx(p,{items:[{title:"前言",key:"preface",href:"#preface"},{title:"有哪些浏览器?",key:"browsers",href:"#browsers"},{title:"浏览器的主要功能",key:"functionality",href:"#functionality"},{title:"浏览器的架构",key:"structure",href:"#structure"},{title:"主要流程",key:"mainFlow",href:"#mainFlow",children:[{title:"主要流程案例",key:"examples",href:"#examples"},{title:"解析",key:"parse",href:"#parse"},{title:"词法分析和语法分析",key:"parser",href:"#parser"},{title:"解析案例",key:"parsingExample",href:"#parsingExample"},{title:"词法和语法的正式定义",key:"formal",href:"#formal"},{title:"解释器的类型",key:"parseType",href:"#parseType"}]},{title:"HTML解析",key:"htmlParser",href:"#htmlParser",children:[{title:"HTML DTD",key:"dtd",href:"#dtd"},{title:"DOM",key:"dom",href:"#dom"},{title:"解析算法",key:"algo",href:"#algo"},{title:"切分算法",key:"tokenizationAlgo",href:"#tokenizationAlgo"},{title:"树的构建算法",key:"treeAlgo",href:"#treeAlgo"},{title:"解析完成后的操作",key:"parseFinished",href:"#parseFinished"}]},{title:"CSS解析",key:"cssParser",href:"#cssParser"},{title:"加载scripts和样式表的顺序",key:"order",href:"#order",children:[{title:"Scripts",key:"scripts",href:"#scripts"},{title:"预测解析",key:"speculative",href:"#speculative"},{title:"样式表",key:"styleSheet",href:"#styleSheet"}]},{title:"Render Tree的构建",key:"renderTree",href:"#renderTree",children:[{title:"Render tree和DOM tree的关系",key:"renderTreeRelate",href:"#renderTreeRelate"},{title:"样式计算",key:"styleComputation",href:"#styleComputation"},{title:"共享样式数据",key:"share",href:"#share"},{title:"分割为结构体",key:"division",href:"#division"},{title:"简单匹配的操作",key:"manipulate",href:"#manipulate"},{title:"样式表的顺序",key:"cascade",href:"#cascade"},{title:"明确定义",key:"specificity",href:"#specificity"}]},{title:"布局",key:"layout",href:"#layout",children:[{title:"标志位系统",key:"dirtyBit",href:"#dirtyBit"},{title:"全局和增量的布局",key:"global",href:"#global"},{title:"优化",key:"optimization",href:"#optimization"},{title:"布局过程",key:"layoutProcess",href:"#layoutProcess"},{title:"宽度计算",key:"widthCalculation",href:"#widthCalculation"},{title:"换行",key:"line",href:"#line"}]},{title:"渲染",key:"painting",href:"#painting",children:[{title:"全局和增量",key:"globalAndIncremental",href:"#globalAndIncremental"},{title:"渲染顺序",key:"paintingOrder",href:"#paintingOrder"},{title:"动态修改",key:"dynamicChanges",href:"#dynamicChanges"},{title:"渲染引擎线程",key:"thread",href:"#thread"},{title:"事件循环",key:"eventLoop",href:"#eventLoop"}]},{title:"CSS视觉模型",key:"cssVisualModel",href:"#cssVisualModel",children:[{title:"Canvas",key:"canvas",href:"#canvas"},{title:"CSS盒模型",key:"box",href:"#box"},{title:"位置方案",key:"position",href:"#position"},{title:"盒子类型",key:"boxType",href:"#boxType"},{title:"定位",key:"positioning",href:"#positioning"},{title:"层级展示",key:"layer",href:"#layer"}]}]})]})}export{se as default};
