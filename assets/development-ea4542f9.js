import{j as e,d as l,e as s}from"./index-12c11ae8.js";import{A as r}from"./Anchor-cb8b8329.js";const i="/luoyunlai/assets/development-aa3374be.png";function t(){return e.jsxs("article",{id:"rootArticle",className:l.article,children:[e.jsxs("main",{className:l.content,children:[e.jsx("h2",{id:"pre",className:"font-semibold text-h2 mb-2",children:"前端技术发展轨迹"}),e.jsx(s,{src:i}),e.jsx("br",{}),e.jsx("h3",{id:"ajax",className:l.articleSubTitle,children:"ajax"}),"早期并没有前端工程师这个独立的职位，随着ajax技术出现，才开始有前后端分离模式的诞生和流行，主要就是前端通过ajax向后端发起请求，后端提供Restful接口的协作方式",e.jsx("h3",{id:"mvc",className:l.articleSubTitle,children:"MVC(Model View Controller)"}),"MVC是一种软件架构模式，将应用程序分为三个主要部分，模型（Model）、视图（View）和控制器（Controller），它改变了命令式的代码组织方式。用户通过视图触发操作，控制器接收操作并调用模型的方法进行处理，模型处理完数据后将结果返回给控制器， 控制器再根据结果更新视图。",e.jsxs("ul",{className:l.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"模型（Model）:"}),"负责处理应用程序的数据和业务逻辑，与数据库或其他数据存储进行交互，通常用于存储和管理数据对象，以及执行数据操作和验证等任务。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"视图（View）:"}),"主要用于展示数据给用户，它是用户和应用程序交互的界面部分，通常由HTML、CSS、JavaScript等技术实现，负责将模型中的数据以特定的形式呈现给用户"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"控制器（Controller）:"}),"作为中间桥梁，接受用户的输入和操作，根据请求调用相应的模型方法来处理数据，并根据处理结果选择合适的视图来展示给用户，起到了协调模型和试图的作用。"]})]}),e.jsx("h3",{id:"mvvm",className:l.articleSubTitle,children:"MVVM(Model View ViewModel)"}),"它由MVC架构演变而来，",e.jsx("code",{children:"Controller"}),"变为",e.jsx("code",{children:"ViewModel"}),"，视图通过数据绑定与ViewModel建立关系，ViewModel监听视图的变化并更新模型，同时模型的变化也会通过ViewModel自动更新到视图上，实现了数据的双向绑定。",e.jsx("strong",{children:"和MVC的区别"}),e.jsx("br",{}),e.jsxs("ul",{className:l.ul,children:[e.jsx("strong",{children:"数据绑定方式："}),e.jsx("br",{}),e.jsx("li",{children:"MVC需要在控制器中手动更新视图，数据流向相对单向。MVVM的数据变化自动同步，大幅减少了手动操作DOM更新视图的代码，提高了开发效率和可维护性。"}),e.jsx("li",{children:"MVC中Controller职责较重，需要处理大量的业务逻辑、视图和模型之间的交互逻辑，导致代码复杂度过高。MVVM中ViewModel承担了更多与视图相关的数据转换工作，使得视图和模型之间的职责边界更加清晰，视图只关注展示，模型只关注数据和业务逻辑。"})]}),e.jsx("h3",{id:"flux",className:l.articleSubTitle,children:"Flux"}),"Flux是Facebook提出的一种应用程序架构模式，它采用单向数据流的方式来组织应用程序。主要包含四个部分：",e.jsxs("ul",{className:l.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Action："}),"动作的抽象，包含动作的类型和携带的数据。它是改变Store中状态的唯一方式，通常由用户交互或服务端响应触发。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Dispatcher："}),"调度中心，负责接收Action并将其分发给所有注册的Store。它确保了数据流的有序性，所有Store接收到Action的顺序是确定的。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Store："}),"数据和业务逻辑的集中管理者，负责存储应用状态并处理由Dispatcher分发的Action。当Store中的数据发生变化时，会触发一个change事件通知视图更新。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"View："}),"展示层，负责渲染界面并响应用户交互。当用户操作触发Action时，通过Dispatcher分发到Store，Store更新后通知View进行重新渲染。"]})]}),e.jsx("strong",{children:"和MVC的区别"}),e.jsx("br",{}),e.jsxs("ul",{className:l.ul,children:[e.jsx("li",{children:"Flux采用单向数据流，数据流向更加清晰可预测。而MVC中数据流向可能是双向的，在复杂应用中可能导致数据流向混乱。"}),e.jsx("li",{children:"Flux中Store之间的依赖通过Dispatcher来管理，避免了MVC中Model之间可能产生的复杂依赖关系。"})]}),e.jsx("h3",{id:"node",className:l.articleSubTitle,children:"Node.js"}),"随着Node.js的出现，各种前端工具如雨后春笋般出现：",e.jsxs("ul",{className:l.ul,children:[e.jsx("li",{children:"1. webpack等库，真正的实现了前端的工程化。"}),e.jsx("li",{children:"2. bff层，前端可以自行编写后端服务或SSR"})]}),e.jsx("h3",{id:"serverless",className:l.articleSubTitle,children:"Serverless"}),"实现bff层后，自然涉及到服务的管理，那么无形中增大了人力成本。Serverless是一个很好的解决方案，将服务器的运维等集中管理，研发可以专注于实现云函数。",e.jsx("h3",{id:"plan",className:l.articleSubTitle,children:"技术方案"}),"前端发展的过程中诞生了很多针对不同场景的技术方案：",e.jsxs("ul",{className:l.ul,children:[e.jsx("li",{children:"1. ui：组件化方案(antd)、配置化解决方案(低代码)"}),e.jsx("li",{children:"2. 单体应用的工程方案：微前端"}),e.jsx("li",{children:"3. 平台化方案：PWA、小程序"}),e.jsx("li",{children:"4. 跨端方案：hybrid、ReactNative、Flutter"})]}),e.jsx("h3",{id:"render",className:l.articleSubTitle,children:"渲染方案"}),"CSR => SSR => NSR =>",e.jsx("strong",{children:"SSR"}),e.jsx("br",{}),"现在SSR有了hydration的方案，将html和数据同时通过请求返回。",e.jsx("strong",{children:"NSR"}),e.jsx("br",{}),"csr和ssr都知道，那么nsr又是啥？",e.jsx("br",{}),"nsr是hybrid的情况下的技术方案，借助native来渲染生成html数据，借助离线数据实现预渲染。",e.jsx("strong",{children:"ESR"}),e.jsx("br",{})]}),e.jsx(r,{items:[{title:"前端技术发展轨迹",key:"pre",href:"#pre",children:[{title:"ajax",key:"ajax",href:"#ajax"},{title:"MVC",key:"mvc",href:"#mvc"},{title:"MVVM",key:"mvvm",href:"#mvvm"},{title:"Node.js",key:"node",href:"#node"},{title:"Serverless",key:"serverless",href:"#serverless"},{title:"技术方案",key:"plan",href:"#plan"},{title:"渲染方案",key:"render",href:"#render"}]}]})]})}export{t as default};
