import{j as e,d as l,e as x}from"./index-a233d2e0.js";import{U as i}from"./useMarkdown-30fc6593.js";import{x as h,y as a,z as j,G as o,J as t}from"./index-47083441.js";import{A as f}from"./Anchor-31b59515.js";import"./index-de0c2df5.js";const m="/luoyunlai/assets/reconcileSingleElement-cd47bf1a.png";function E(){const d=e.jsx(i,{markdown:h}),s=e.jsx(i,{markdown:a}),c=e.jsx(i,{markdown:j}),n=e.jsx(i,{markdown:o}),r=e.jsx(i,{markdown:t});return e.jsxs("article",{id:"rootArticle",className:l.article,children:[e.jsxs("main",{className:l.content,children:[e.jsx("h2",{id:"diff",className:"font-semibold text-h2 mb-2",children:"Diff"}),e.jsx("code",{children:"Diff算法"}),"就是对比当前组件和该组件上次更新时对应的Fiber节点，并生成新的Fiber节点的过程。",e.jsx("br",{}),e.jsx("br",{}),"它的时间复杂度O(n^3)，n为树中元素的数量。所以在真正进入算法之前，必然要有条件限制。",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 只对同级元素进行diff，如果一个DOM节点更新中跨越了层级，不会复用"}),e.jsx("li",{children:"2. 类型或者tag不同，不会复用"}),e.jsx("li",{children:"3. 可以通过key属性来表示该元素能保持稳定"})]}),e.jsx("br",{}),"从入口函数",e.jsx("code",{children:"reconcileChildFibers"}),"开始看，该函数根据",e.jsx("code",{children:"newChild"}),"的类型来处理",e.jsx("div",{className:l.assist,children:"packages\\react-reconciler\\src\\ReactChildFiber.new.js"}),d,"基本可以分为两类",e.jsxs("ul",{children:["1. ",e.jsx("code",{children:"newChild"}),"类型为",e.jsx("code",{children:"object"}),"、",e.jsx("code",{children:"number"}),"、",e.jsx("code",{children:"string"}),"，代表同级为单节点"]}),e.jsxs("ul",{children:["2. ",e.jsx("code",{children:"newChild"}),"类型为",e.jsx("code",{children:"Array"}),"，同级为多节点"]}),e.jsx("h2",{id:"single",className:l.articleTitle,children:"单节点diff"}),"以",e.jsx("code",{children:"object"}),"类型为例，进入",e.jsx("code",{children:"reconcileSingleElement"}),e.jsx(x,{src:m}),s,"有个细节需要关注：",e.jsxs("ul",{className:l.ul,children:[e.jsxs("li",{children:["当",e.jsx("code",{children:"child!==null"}),"且key相同且type不同时，将child和兄弟fiber都标记删除"]}),e.jsxs("li",{children:["当",e.jsx("code",{children:"child!==null"}),"且key不同时仅删除child"]})]}),"因为当key相同时且type不同时，代表已经找到唯一的可能性，不能复用的话剩下的也不用看了，都标记删除。当key不同时只代表该fiber不能被复用，所以仅仅标记该fiber删除。",e.jsx("h2",{id:"multi",className:l.articleTitle,children:"多节点diff"}),"多节点Diff的情况如下：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 节点更新，属性变化等"}),e.jsx("li",{children:"2. 节点新增或减少"}),e.jsx("li",{children:"3. 位置变化"})]}),"节点更新是最常见的场景，所以先判断节点是否属于更新，再处理剩余节点。 几个关键步骤",e.jsxs("ul",{children:[e.jsxs("li",{children:["1.同时从头部开始遍历新旧节点，调用",e.jsx("code",{children:"updateSlot"}),"比较",e.jsx("code",{children:"newChildren[i]"}),"和",e.jsx("code",{children:"oldFiber"}),"，如果可复用会更新节点，",e.jsx("code",{children:"i++"}),e.jsx("br",{}),"继续比较",e.jsx("code",{children:"newChildren[i]"}),"和",e.jsx("code",{children:"olderFiber.sibling"}),"，直到不可复用或者旧节点遍历结束为止。",c]}),e.jsx("li",{children:"2. 如果新节点遍历完了，删除剩余旧节点"}),e.jsx("li",{children:"3. 如果旧节点遍历完了，插入剩余新节点"}),e.jsxs("li",{children:["4. 都没遍历完，进入真正的diff",e.jsx("br",{}),"首先将未处理的",e.jsx("code",{children:"oldFiber"}),"存入",e.jsx("code",{children:"key:oldFiber"}),"的map",n,"然后再遍历",e.jsx("code",{children:"newChildren"}),",如果可以在map中找到，说明可复用，在map中删除该key。调用",e.jsx("code",{children:"placeChild"}),"来标记",r,"总结就是",e.jsx("code",{children:"oldIndex < lastPlacedIndex"}),"，需要右移，否则不移动"]})]}),"举个例子:",e.jsx("br",{}),"abcd",e.jsx("br",{}),"acdb",e.jsxs("ul",{children:[e.jsxs("li",{children:["1. 节点a可以复用，",e.jsx("code",{children:"lastPlacedIndex=1"})]}),e.jsxs("li",{children:["2. 生成map，开始遍历剩余newChildren ",e.jsx("code",{children:"[c,d,b]"})]}),e.jsxs("li",{children:["3. 节点c，oldIndex为2,，",e.jsx("code",{children:"oldIndex > lastPlacedIndex"}),"，c不动，lastPlacedIndex=2"]}),e.jsxs("li",{children:["4. 节点d，oldIndex为3，",e.jsx("code",{children:"oldIndex > lastPlacedIndex"}),"，d不动，lastPlacedIndex=3"]}),e.jsxs("li",{children:["5. 节点b，oldIndex为1，",e.jsx("code",{children:"oldIndex < lastPlacedIndex"}),"，b右移"]})]})]}),e.jsx(f,{items:[{title:"Diff",key:"diff",href:"#diff"},{title:"单节点diff",key:"single",href:"#single"},{title:"多节点diff",key:"multi",href:"#multi"}]})]})}export{E as default};
