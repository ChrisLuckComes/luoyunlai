import{j as e,d as s}from"./index-058c629c.js";import{U as c}from"./useMarkdown-8861a8d5.js";import{K as f,N as k,O as S,Q as p,T as E,V as R,X as b,Y as T,Z as N,_ as A,$ as _,p as C,r as H}from"./index-47083441.js";import{A as g}from"./Anchor-75b3735e.js";import{A as w}from"./index-55aa0a3c.js";import"./index-a0d8c73b.js";import"./pickAttrs-04ad8a74.js";function y(){const d=e.jsx(c,{markdown:f}),r=e.jsx(c,{markdown:k}),i=e.jsx(c,{markdown:S}),t=e.jsx(c,{markdown:p}),l=e.jsx(c,{markdown:E}),o=e.jsx(c,{markdown:R}),n=e.jsx(c,{markdown:b}),a=e.jsx(c,{markdown:T}),h=e.jsx(c,{markdown:N}),x=e.jsx(c,{markdown:A}),j=e.jsx(c,{markdown:_}),u=e.jsx(c,{markdown:C}),m=e.jsx(c,{markdown:H});return e.jsxs("article",{id:"rootArticle",className:s.article,children:[e.jsxs("main",{className:s.content,children:[e.jsx("h2",{id:"hooks",className:"font-semibold text-h2 mb-2",children:"Hooks"}),"什么是Hooks?它的直译是钩子，函数组件中使用它们可以实现和",e.jsx("code",{children:"ClassComponent"}),"一样的功能。它是 React实现",e.jsx("code",{children:"代数效应(Algebraic Effects)"}),"的方式，我们不需要关注函数组件的state在",e.jsx("code",{children:"useState"}),"这些",e.jsx("code",{children:"hook"}),"中是怎么保存和处理的，专注业务逻辑的实现就行。",e.jsxs("div",{className:s.assist,children:["代数效应可以理解为将主要逻辑跟副作用分开，比如",e.jsx("code",{children:"try/catch"}),",",e.jsx("code",{children:"async/await"})]}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h2",{id:"dataStructure",className:s.articleTitle,children:"数据结构"}),e.jsx("div",{className:s.assist,children:"packages\\react-reconciler\\src\\ReactFiberHooks.new.js"}),d,e.jsx("h3",{id:"memoizedState",className:s.articleSubTitle,children:"memoizedState"}),e.jsx(w,{message:e.jsxs("ul",{className:s.ul,children:["hook和FunctionComponent都存在",e.jsx("code",{children:"memoizedState"}),"属性，不要混淆。",e.jsxs("li",{children:[e.jsx("code",{children:"fiber.memoizedState"}),": FunctionComponent对应的",e.jsx("code",{children:"fiber"}),"保存的hooks链表"]}),e.jsxs("li",{children:[e.jsx("code",{children:"hook.memoizedState"}),": hooks链表中保存的单一hook对应的数据"]})]}),type:"warning"}),"不同类型的",e.jsx("code",{children:"hook"}),"的",e.jsx("code",{children:"memorizedState"}),"保存不同类型数据，具体如下：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:["useState: 对于",e.jsx("code",{children:"const [state, updateState] = useState(initialState)"}),"，",e.jsx("code",{children:"memorizedState"}),"保存state的值"]}),e.jsxs("li",{children:["useReducer：对于",e.jsxs("code",{children:["const [state, dispatch] = useReducer(reducer, ",")"]}),"，保存state的值"]}),e.jsxs("li",{children:["useEffect：",e.jsx("code",{children:"memorizedState"}),"保存包含",e.jsx("code",{children:"useEffect回调函数"}),"、",e.jsx("code",{children:"依赖项"}),"等的链表数据结构",e.jsx("code",{children:"effect"}),"，effect同时会保存在",e.jsx("code",{children:"fiber.updateQueue"}),"中，创建过程如下",r]}),e.jsxs("li",{children:["useRef：对于",e.jsx("code",{children:"useRef(1)"}),"，memorizedState保存",e.jsx("code",{children:"{current:1}"})]}),e.jsxs("li",{children:["useMemo：对于",e.jsx("code",{children:"useMemo(callback,[depA])"}),"，memorizedState保存",e.jsx("code",{children:"[callback(),depA]"})]}),e.jsxs("li",{children:["useCallback：对于",e.jsx("code",{children:"useCallback(callback,[depA])"}),"，memorizedState保存",e.jsx("code",{children:"[callback,depA]"}),"，和",e.jsx("code",{children:"useMemo"}),"的区别就是它保存的是函数本身，",e.jsx("code",{children:"useMemo"}),"保存的是执行结果"]}),e.jsx("li",{children:"useContext：没有memorizedState"})]}),e.jsx("h3",{id:"dispatcher",className:s.articleSubTitle,children:"dispatcher"}),"真实的",e.jsx("code",{children:"hooks"}),"中，组件mount时的hook和update时的hook来源于不同的对象，这类对象被称为",e.jsx("code",{children:"dispatcher"}),i,"mount时调用的hook和update时调用的hook是两个不同的函数。",e.jsx("br",{}),e.jsx("br",{}),"在",e.jsx("code",{children:"render"}),"之前，根据",e.jsx("code",{children:"current===null || current.memorized === null"}),"来区分mount和update。",e.jsx("br",{}),"然后将不同情况的",e.jsx("code",{children:"dispatcher"}),"赋值给全局变量",e.jsx("code",{children:"ReactCurrentDispatcher.current"}),t,"执行",e.jsx("code",{children:"render"}),"的时候，从",e.jsx("code",{children:"ReactCurrentDispatcher.current"}),"中寻找需要的hook",e.jsx("h2",{id:"detail",className:s.articleTitle,children:"具体实现"}),e.jsx("h3",{id:"useState",className:s.articleSubTitle,children:"useState和useReducer"}),"它们的工作流程分为",e.jsx("code",{children:"声明阶段"}),"和",e.jsx("code",{children:"调用阶段"}),"举个栗子，有如下函数组件：",l,e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"声明阶段"}),"： ",e.jsx("code",{children:"App"}),"调用时，依次执行",e.jsx("code",{children:"useReducer"}),"和",e.jsx("code",{children:"useState"})]}),e.jsxs("li",{children:[e.jsx("code",{children:"调用阶段"}),"： 点击按钮后，",e.jsx("code",{children:"dispatch"}),"或",e.jsx("code",{children:"updateNum"})]})]}),e.jsx("h3",{id:"define",className:s.articleSubTitle,children:e.jsx("strong",{children:"声明阶段"})}),"函数组件进入",e.jsx("code",{children:"render"}),",调用",e.jsx("code",{children:"beginWork"}),"，会调用",e.jsx("code",{children:"renderWithHooks"}),"。",e.jsx("br",{}),"内部会执行",e.jsx("code",{children:"FunctionComponent"}),"对应函数。",e.jsx("code",{children:"useState"}),"和",e.jsx("code",{children:"useReducer"}),"源码如下：",e.jsx("br",{}),e.jsx("div",{className:s.assist,children:"packages\\react\\src\\ReactHooks.js"}),o,e.jsx("strong",{className:s.h4,children:"mount时"}),e.jsx("code",{children:"mount时"}),"，",e.jsx("code",{children:"useReducer"}),"会调用",e.jsx("code",{children:"mountReducer"}),"，",e.jsx("code",{children:"useState"}),"会调用",e.jsx("code",{children:"mountState"}),e.jsx("div",{className:s.assist,children:"packages\\react-reconciler\\src\\ReactFiberHooks.new.js"}),n,e.jsx("code",{children:"mountWorkInProgressHook"}),"方法会创建并返回对应",e.jsx("code",{children:"hook"}),"，可以看到，两个hook唯一区别是",e.jsx("code",{children:"lastRenderedReducer"}),"字段。",e.jsx("code",{children:"useReducer"}),"的",e.jsx("code",{children:"lastRenderedReducer"}),"为传入的",e.jsx("code",{children:"reducer"}),"参数。",e.jsx("code",{children:"useState"}),"的",e.jsx("code",{children:"lastRenderedReducer"}),"为",e.jsx("code",{children:"basicStateReducer"}),e.jsx("br",{}),e.jsx("code",{children:"basicStateReducer"}),"代码如下：",a,"所以，",e.jsx("code",{children:"useState"}),"就是",e.jsx("code",{children:"reducer"}),"为",e.jsx("code",{children:"basicStateReducer"}),"的",e.jsx("code",{children:"useReducer"}),e.jsx("strong",{className:s.h4,children:"update时"}),e.jsx("code",{children:"mount时"}),"还有微小的差别，而",e.jsx("code",{children:"update"}),"时，",e.jsx("code",{children:"useReducer"}),"和",e.jsx("code",{children:"useState"}),"调用的是同一个函数",e.jsx("code",{children:"updateReducer"}),h,e.jsx("code",{children:"mount"}),"时获取当前",e.jsx("code",{children:"hook"}),"使用的是",e.jsx("code",{children:"mountWorkInProgressHook"}),"，而",e.jsx("code",{children:"update"}),"时使用的是",e.jsx("code",{children:"updateWorkInProgressHook"}),"，原因是：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:"mount"}),"时可以确定是调用",e.jsx("code",{children:"ReactDOM.render"}),"产生的初始化更新，只会执行一次。"]}),e.jsxs("li",{children:[e.jsx("code",{children:"update"}),"可能是事件回调或副作用中触发的更新，也有可能是",e.jsx("code",{children:"render"}),"阶段触发的更新，为了避免无限循环更新，后者需要区别对待。"]})]}),e.jsx("code",{children:"React"}),"使用变量",e.jsx("code",{children:"didScheduleRenderPhaseUpdate"}),"判断是否是",e.jsx("code",{children:"render"}),"阶段的更新。",e.jsx("h3",{id:"call",className:s.articleSubTitle,children:e.jsx("strong",{children:"调用阶段"})}),"调用阶段会执行",e.jsx("code",{children:"dispatchAction"}),"，此时该函数组件对应的",e.jsx("code",{children:"fiber"}),",",e.jsx("code",{children:"hook.queue"}),"已经通过",e.jsx("code",{children:"bind"}),"方法预先作为参数传入。",x,"整个过程可以概括为：创建",e.jsx("code",{children:"update"}),"，将",e.jsx("code",{children:"update"}),"加入",e.jsx("code",{children:"queue.pending"}),"，并开启调度。",e.jsx("h3",{id:"useEffect",className:s.articleSubTitle,children:"useEffect"}),"深入",e.jsx("code",{children:"flushPassiveEffects"}),"方法看",e.jsx("code",{children:"useEffect"}),"的工作原理。",e.jsx("strong",{className:s.h4,children:"flushPassiveEffectsImpl"}),e.jsx("code",{children:"flushPassiveEffects"}),"内部设置优先级，执行",e.jsx("code",{children:"flushPassiveEffectsImpl"}),j,e.jsx("code",{children:"flushPassiveEffectsImpl"}),"主要做三件事：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:["调用",e.jsx("code",{children:"useEffect"}),"在上一次",e.jsx("code",{children:"render"}),"的销毁函数"]}),e.jsxs("li",{children:["调用",e.jsx("code",{children:"useEffect"}),"本次",e.jsx("code",{children:"render"}),"的回调函数"]}),e.jsx("li",{children:"如果存在同步任务，不需要等待下次事件循环的宏任务，提前执行"})]}),e.jsx("code",{children:"v16.13.1"}),"之前第一步是同步执行的，之后都改为异步执行了。",e.jsx("strong",{className:s.h4,children:"阶段一：销毁函数的执行"}),e.jsx("code",{children:"useEffect"}),"需要所有组件的",e.jsx("code",{children:"useEffect"}),"的销毁函数都执行完后才能执行任意一个",e.jsx("code",{children:"useEffect"}),"的回调函数， 因为多个组件可能共用同一个ref，",e.jsx("code",{children:"useLayoutEffect"}),"也是一样。",e.jsx("br",{}),e.jsx("br",{}),"在阶段一，会遍历并执行所有",e.jsx("code",{children:"useEffect"}),"的销毁函数",u,e.jsx("strong",{className:s.h4,children:"阶段二：回调函数的执行"}),m]}),e.jsx(g,{items:[{title:"Hooks",key:"hooks",href:"#hooks"},{title:"数据结构",key:"dataStructure",href:"#dataStructure",children:[{title:"memoizedState",key:"memoizedState",href:"#memoizedState"},{title:"dispatcher",key:"dispatcher",href:"#dispatcher"}]},{title:"具体实现",key:"detail",href:"#detail",children:[{title:"useState和useReducer",key:"useState",href:"#useState",children:[{title:"声明阶段",key:"define",href:"#define"},{title:"调用阶段",key:"call",href:"#call"}]},{title:"useEffect",key:"useEffect",href:"#useEffect"}]}]})]})}export{y as default};
