import{j as e,d as s}from"./index-3e783dff.js";import{A as n}from"./Anchor-49c59a55.js";import{U as i}from"./useMarkdown-7c2fc3fe.js";import"./index-b7ab68f6.js";const c=`\`\`\`ts 
import singleSpa from 'single-spa';

singleSpa.registerApplication({
    name: 'app1',
    app: () => import('./app1/app1.js'),
    activeWhen: '/app1'
});

singleSpa.start();
\`\`\``,a=`\`\`\`ts
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
    {
        name: 'app1',
        entry: '//localhost:8081',
        container: '#sub - app - container',
        activeRule: '/app1'
    }
]);

start();
\`\`\``;function j(){const r=e.jsx(i,{markdown:c}),l=e.jsx(i,{markdown:a});return e.jsxs("article",{id:"rootArticle",className:s.article,children:[e.jsxs("main",{className:s.content,children:[e.jsx("h2",{id:"pre",className:"font-semibold text-h2 mb-2",children:"微前端"}),e.jsx("p",{children:"微前端是一种将前端应用拆分成多个小型、自治的前端应用，并将它们组合成一个整体应用的架构模式。它借鉴了后端微服务架构的思想，旨在解决大型前端项目在开发、部署、维护等方面的复杂性问题， 使得不同的团队可以独立开发、测试、部署各自负责的前端模块。"}),e.jsx("br",{}),e.jsx("h2",{id:"plan",className:"font-semibold text-h2 mb-2",children:"常见方案"}),e.jsx("h3",{id:"iframe",className:s.articleSubTitle,children:"iframe方案"}),"使用",e.jsx("code",{children:"iframe"}),"标签将子应用嵌入到主应用中",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"优点"}),e.jsx("br",{}),e.jsxs("ul",{className:s.subUl,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"隔离性强："}),"每个微前端应用在独立的",e.jsx("code",{children:"iframe"}),"中运行，天然具备良好的隔离性，不会影响主应用和其他子应用。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"技术栈无关："}),"子应用可以采用不同的技术栈，如React、Vue等，无兼容性问题。"]})]})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"缺点"}),e.jsx("br",{}),e.jsxs("ul",{className:s.subUl,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"通信复杂："}),"主应用和子应用通信需要通过",e.jsx("code",{children:"postMessage"}),"，通信机制相对复杂。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"性能问题："}),"子应用的加载会带来一定的性能开销，特别是在嵌套多个",e.jsx("code",{children:"iframe"}),"时。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"样式问题："}),"每个",e.jsx("code",{children:"iframe"}),"都有独立的样式，可能会导致和主应用样式不一致，需要进行额外处理。"]})]})]})]}),e.jsxs("ul",{className:s.ul,children:[e.jsx("strong",{children:"实现原理："}),e.jsxs("li",{children:[e.jsxs("strong",{children:["嵌入",e.jsx("code",{children:"iframe"}),"："]}),"在主应用的HTML中使用",e.jsx("code",{children:"iframe"}),"标签，指定",e.jsx("code",{children:"src"}),"为子应用的URL。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"通信机制："}),"主应用和子应用之间使用",e.jsx("code",{children:"window.postMessage"}),"进行通信。主应用向子应用发送消息，子应用可以监听",e.jsx("code",{children:"message"}),"事件来接收消息。"]})]}),e.jsx("h3",{id:"framework",className:s.articleSubTitle,children:"微前端框架方案"}),"使用微前端框架（如qiankun、wujie、microApp、single-spa等）来管理微前端应用。这些框架提供了统一的生命周期管理、通信机制、状态管理等， 使得微前端应用可以更加灵活地进行开发、部署和维护。",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"优点"}),e.jsx("br",{}),e.jsxs("ul",{className:s.subUl,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"标准化管理："}),"框架提供了统一的规范和接口，使得微前端的管理更加标准化和规范化。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"易于集成："}),"可以方便的集成不同技术栈的微前端应用，减少开发成本。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"社区支持："}),"热门框架有活跃的社区支持，能够及时获取最新的技术方案。"]})]})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"缺点"}),e.jsx("br",{}),e.jsxs("ul",{className:s.subUl,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"学习成本："}),"需要学习框架的使用方法和理念，增加了开发人员的学习成本。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"框架约束："}),"可能受框架限制，导致部分需求无法实现。"]})]})]})]}),e.jsxs("ul",{className:s.ul,children:[e.jsx("strong",{children:"实现原理："}),e.jsxs("li",{children:[e.jsx("strong",{children:"应用注册："}),"在主应用中注册子应用，并指定子应用的入口文件、路由、生命周期、主要函数等。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"路由匹配："}),"框架根据当前的URL进行路由匹配，当匹配到某个子应用的路由规则时，会调用该应用的加载函数，动态加载代码。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"生命周期管理："}),"框架会根据应用的状态（如加载、挂载、卸载等）调用相应的生命周期函数，确保应用的正确运行。"]})]}),e.jsx("h2",{id:"topFramework",className:"font-semibold text-h2 mb-2",children:"主流框架"}),e.jsx("h3",{id:"single-spa",className:s.articleSubTitle,children:"single-spa"}),e.jsx("p",{children:"single-spa 是一个用于构建微前端架构的 JavaScript 库。它允许开发者将多个独立的前端应用组合成一个整体应用， 允许不同的团队使用不同的技术栈独立开发和部署。"}),e.jsx("br",{}),"开发者需要注册每个微前端应用，需要指定应用名称、加载函数。singleSpa会根据当前的URL进行路由匹配，当匹配到某个子应用的",e.jsx("code",{children:"activeWhen"}),"规则时，会调用该应用的加载函数，动态加载代码；当应用需要卸载时，调用卸载函数",r,e.jsx("h3",{id:"qiankun",className:s.articleSubTitle,children:"qiankun"}),e.jsx("p",{children:"qiankun是蚂蚁开源出品，基于single-spa进行了二次封装和拓展的微前端框架，提供了更简单易用的API和更丰富的功能。"}),e.jsx("br",{}),"qiankun采用主应用+子应用的架构模式，主应用通过",e.jsx("code",{children:"registerMicroApps"}),"注册子应用，并指定子应用的入口文件、路由、生命周期、主要函数等。",e.jsx("br",{}),"qiankun提供了沙箱机制，确保子应用之间的隔离性，主应用和子应用之间可以通过",e.jsx("code",{children:"initGlobalState"}),"实现状态的共享和通信。",l,e.jsx("h3",{id:"wujie",className:s.articleSubTitle,children:"wujie"}),"wujie是腾讯开源的微前端框架，基于WebComponent+iframe，提供样式隔离（Shadow DOM）、JS沙箱（Proxy代理）、高性能加载等能力。",e.jsx("br",{}),e.jsx("strong",{children:"样式隔离："}),"当加载子应用时，将子应用的DOM节点包裹在Shadow DOM中，确保子应用的样式不会影响到主应用。",e.jsx("br",{}),e.jsx("strong",{children:"JS沙箱："}),"使用Proxy对window对象进行代理，子应用对window对象的修改不会影响到主应用的全局window对象。",e.jsx("h3",{id:"microApp",className:s.articleSubTitle,children:"microApp"}),"microApp是京东开源的微前端框架，它采用无iframe的架构模式，通过动态创建DOM节点并将子应用的HTML、CSS和JavaScript插入到主应用的指定容器中进行渲染。在渲染过程中， microApp会对HTML进行解析和处理，将其中的资源路径进行重写，确保子应用的资源能够正确加载。它的沙箱机制和wujie类似，但除了Shadow DOM来实现样式隔离之外，还支持添加唯一的样式前缀。",e.jsx("br",{}),"microApp提供了一套简单易用的通信API，主应用和子应用可以通过",e.jsx("code",{children:"microApp.emit"}),"方法发送消息，通过",e.jsx("code",{children:"microApp.on"}),"方法接收消息。"]}),e.jsx(n,{items:[{title:"微前端",key:"pre",href:"#pre",children:[]},{title:"常见方案",key:"plan",href:"#plan",children:[{title:"iframe方案",key:"iframe",href:"#iframe",children:[]},{title:"微前端框架方案",key:"framework",href:"#framework",children:[]}]},{title:"主流框架",key:"topFramework",href:"#topFramework",children:[{title:"single-spa",key:"single-spa",href:"#single-spa",children:[]},{title:"qiankun",key:"qiankun",href:"#qiankun",children:[]},{title:"wujie",key:"wujie",href:"#wujie",children:[]},{title:"microApp",key:"microApp",href:"#microApp",children:[]}]}]})]})}export{j as default};
