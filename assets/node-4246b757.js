import{j as e,d as s,e as l}from"./index-12c11ae8.js";import{U as r}from"./useMarkdown-141d10e7.js";import{A as n}from"./Anchor-cb8b8329.js";const d="/luoyunlai/assets/nodeModel-42166b9a.png",o="/luoyunlai/assets/libuv-321bdb36.webp",a="/luoyunlai/assets/brainless-f6e04f2a.webp",t="/luoyunlai/assets/flow-ebe50d62.png",h=`\`\`\`sql
   ┌───────────────────────────┐
┌─>           timers          
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll                                        <───┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└─      close callbacks      
    └───────────────────────────┘
\`\`\``,j=`\`\`\`ts
const fs = require('fs');

function someAsyncOperation(callback) {
  // 假设读取文件需要95ms
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(delay + 'ms have passed since I was scheduled');
}, 100);

// 执行函数
someAsyncOperation(() => {
  const startCallback = Date.now();

  // 空过，耗时10ms
  while (Date.now() - startCallback < 10) {

  }
});
\`\`\``;function p(){const i=e.jsx(r,{markdown:h}),c=e.jsx(r,{markdown:j});return e.jsxs("article",{id:"rootArticle",className:s.article,children:[e.jsxs("main",{className:s.content,children:[e.jsx("h2",{id:"intro",className:"font-semibold text-h2 mb-2",children:"Node.js"}),"什么是Node.js?官网一句话介绍：Node.js是一个开源，跨平台的JavaScript运行时环境。",e.jsx("div",{className:s.assist,children:"Node.js® is an open-source, cross-platform JavaScript runtime environment."}),e.jsx("br",{}),"Node.js基于V8引擎运行，脱离了浏览器，因此可以胜任任意类型的项目。Node.js app单进程运行，不需要对每一个请求都创建一个线程，原生提供了异步的I/O设置以防止js代码阻塞，所以Node.js可以单服务器承担大量的并发连接。",e.jsx("br",{}),e.jsx("strong",{children:"它最特别的优势就是前端同学们👨‍💻👩‍💻都熟js，不需要学习新语言就可以写服务端的代码。只需要几行代码就可以启动一个服务，如下"}),e.jsx("iframe",{src:"https://codesandbox.io/embed/relaxed-shaw-5u3725?fontsize=14&hidenavigation=1&theme=dark",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden",margin:"10px 0"},title:"relaxed-shaw-5u3725",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),e.jsx("br",{}),"Node.js核心依赖项如下：",e.jsx("br",{}),e.jsx("strong",{children:"类库"}),"：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://v8.dev/docs/",children:"V8"})}),"：V8为Node.js提供了JavaScript引擎，Node.js通过V8 C++的API函数接口进行操控。V8由谷歌维护，用于谷歌浏览器中。"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"http://docs.libuv.org/",children:"libuv"})}),"：它是C语言的类库，用于非阻塞型的I/O操作，同时在所有支持的操作系统上保持一致的接口。它提供了一些机制来处理文件系统、DNS、网络、子进程、管道、信号量控制、轮询机制和数据流。它也提供了一个线程池，用于无法在操作系统层面进行异步操作的任务卸载。"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://github.com/nodejs/llhttp",children:"llhttp"})}),"：由C编写，用于HTTP解析。"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://c-ares.haxx.se/docs.html",children:"c-ares"})}),"：异步DNS请求"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://www.openssl.org/docs/",children:"OpenSSL"})}),"：在",e.jsx("code",{children:"tls"}),"和",e.jsx("code",{children:"crypto"}),"模块中使用，它提供了密码函数。"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://www.zlib.net/manual.html",children:"zlib"})}),"：Node.js使用zlib创建同步、异步和数据流压缩、解压缩接口。"]})]}),e.jsx("strong",{children:"工具"}),"：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://docs.npmjs.com/",children:"npm"})}),"：Node.js的包管理器。"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://gyp.gsrc.io/docs/UserDocumentation.md",children:"gyp"})}),"：从V8拷贝而来，基于python的项目生成工具。它可以生成跨平台的项目文件。"]}),e.jsxs("li",{children:[e.jsx("code",{children:e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://code.google.com/p/googletest/wiki/V1_7_Documentation",children:"gtest"})}),"：C/C++程序测试工具。"]})]}),e.jsx("br",{}),"那么这些技术是如何组合的呢？如下是node.js的架构图",e.jsx(l,{src:d}),e.jsxs("ul",{className:s.ul,children:[e.jsx("li",{children:"最上层是Node API，可以直接js调用"}),e.jsxs("li",{children:["中间",e.jsx("code",{children:"node bindings"}),"，js通过它可以和C/C++通信"]}),e.jsx("li",{children:"最底层向node bindings提供api服务"})]}),e.jsx("h2",{id:"bindings",className:s.articleTitle,children:"Node bindings"}),"C/C++有很多功能js是没有的，例如文件系统，http等，但js不能直接调用C++的库，所以需要一个中间人，Node bindings就是这个中间人。",e.jsx("br",{}),"Node.js是这样处理的：",e.jsxs("ul",{className:s.ul,children:[e.jsx("li",{children:"将库用C++封装，文件类型为xxx.cpp"}),e.jsx("li",{children:"编译为.node文件"}),e.jsxs("li",{children:["js可以直接",e.jsx("code",{children:"require"}),"这个",e.jsx("code",{children:".node"}),"文件"]})]}),"示例代码见",e.jsx("a",{className:s.href,target:"_blank",rel:"noreferrer",href:"https://github.com/nodejs/node-addon-examples",children:"Node.js C++ addon examples 官方示例仓库"}),"，拉到本地从hello world开始看",e.jsx("br",{}),e.jsx("br",{}),e.jsx(l,{src:a}),e.jsx("h2",{id:"v8",className:s.articleTitle,children:"V8"}),e.jsx("code",{children:"V8"}),"是谷歌开源的高性能js引擎，用C++写的，功能如下",e.jsxs("ul",{className:s.ul,children:[e.jsx("li",{children:"编译并运行js代码"}),e.jsx("li",{children:"管理内存"}),e.jsx("li",{children:"垃圾收集"}),e.jsx("li",{children:"实现ECMA标准中的类型、运算符、对象和函数"})]}),e.jsx("h2",{id:"libuv",className:s.articleTitle,children:"libuv"}),"libuv是一个C库，它支持多平台的异步I/O操作，啥是I/O？",e.jsxs("ul",{className:s.ul,children:[e.jsx("li",{children:"文件"}),e.jsx("li",{children:"网络"}),e.jsx("li",{children:"线程池"}),e.jsx("li",{children:"...更多，如下图"})]}),e.jsx(l,{src:o}),e.jsx("h2",{id:"workflow",className:s.articleTitle,children:"工作流程"}),e.jsx(l,{src:t}),e.jsx("br",{}),"以读取文件为例：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:"Application"}),"就是代码，然后",e.jsx("code",{children:"V8运行代码"})]}),e.jsxs("li",{children:["运行代码到需要读取文件，",e.jsx("code",{children:"libuv"}),"开一个线程读文件"]}),e.jsxs("li",{children:["读完文件后，操作系统返回事件给",e.jsx("code",{children:"event loop"}),"，",e.jsx("code",{children:"event loop"}),"把文件传回给",e.jsx("code",{children:"V8"})]})]}),e.jsx("h3",{id:"eventLoop",className:s.articleSubTitle,children:"事件循环(Event Loop)"}),"它是Node.js处理非阻塞I/O操作的机制，会把操作转移到系统内核中去。js是单线程没错，但是大多数系统内核都是多线程的，它们可以在后台处理多种操作，当一个操作完成的时候，内核通知Node.js将合适的回调函数添加到队列里等待时机执行。",e.jsx("br",{}),e.jsx("br",{}),"当Node.js启动后，它会初始化",e.jsx("code",{children:"Event Loop"}),"，处理已提供的输入脚本，它可能会调用一些异步的API、调度定时器，或者调用",e.jsx("code",{children:"process.nextTick"}),"，然后开始处理",e.jsx("code",{children:"Event Loop"}),"，流程如下，它展示了操作顺序的简化概览：",i,e.jsx("div",{className:s.assist,children:"每个框都是事件循环机制的一个阶段。"}),e.jsx("br",{}),"每个阶段都有一个FIFO队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后之心该阶段队列中的回调，直到队列用尽或已执行到最大的回调数。当执行完成后，事件循环将移动到下一阶段，以此类推。",e.jsx("br",{}),e.jsx("br",{}),e.jsx("h3",{id:"stage",className:s.articleSubTitle,children:"阶段概述"}),e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"timers(计时器)"}),"：本阶段执行已经被",e.jsx("code",{children:"setTimeout"}),"和",e.jsx("code",{children:"setInterval"}),"的调度回调函数。",e.jsx("br",{}),e.jsx("br",{}),"计时器可以指定阈值，而不是用户希望回调执行的确切时间。经过指定的时间间隔后，计时器回调将被尽可能早地运行，但是操作系统调度或其他正在运行的回调可能会延迟它们 (由轮询阶段控制)。举个例子，设置了一个100ms的定时器，假设读取文件需要95ms：",c,"当事件循环进入poll阶段时，它由一个空队列（此时",e.jsx("code",{children:"fs.readFile"}),"暂未完成），因此它将等待剩下的毫秒数，直到达到最快的一个计时器阈值为止。当它等待95ms后，",e.jsx("code",{children:"fs.readFile"}),"完成，它的那个需要10毫秒才能完成的回调将被添加到轮询队列中并执行。当回调完成后，队列为空，此时事件循环机制发现计时器最快的阈值(100ms)已达到，将回到计时器阶段，执行计时器阶段。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"I/O callbacks(待定回调)"}),"：执行延迟到下一个循环迭代的I/O回调",e.jsx("br",{}),e.jsx("br",{}),"此阶段对某些系统操作（如TCP错误类型）执行回调。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"idle,prepare"}),"：仅系统内部使用"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"poll(轮询)"}),"：检索新的I/O事件；执行与I/O相关的回调（除了关闭的回调函数、计时器和",e.jsx("code",{children:"setImmediate"}),"调度的之外），其余情况node将在适当的时候在此阻塞。",e.jsx("br",{}),e.jsx("br",{}),"轮询阶段有两个重要的功能：",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 计算应该阻塞和轮询I/O的时间"}),e.jsx("li",{children:"2. 处理轮询队列里的时间"})]}),"当时间循环进入轮询阶段且没有被调度的计时器时，将发生以下两种情况：",e.jsxs("ul",{className:s.ul,children:[e.jsx("li",{children:"如果轮询队列不是空的，事件循环将循环访问回调队列并同步执行它们，直到队列为空，或者达到系统硬性限制"}),e.jsxs("li",{children:["如果轮询队列是空的：",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:["如果脚本被",e.jsx("code",{children:"setImmediate"}),"调度，则时间循环将结束轮询阶段，继续执行检查阶段"]}),e.jsx("li",{children:"否则等待回调被添加到队列中并立即执行"})]})]})]}),"一旦轮询队列为空，事件循环将检查已达到时间阈值的计时器。如果有计时器已准备就绪，则事件循环将绕回计时器阶段执行这些计时器的回调。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"check(检查)"}),"：",e.jsx("code",{children:"setImmediate"}),"回调函数在这里执行",e.jsx("br",{}),e.jsx("br",{}),"此阶段允许在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用",e.jsx("code",{children:"setImmediate"}),"后被排列在队列中，则事件循环可能到检查阶段而不是等待。",e.jsx("br",{}),e.jsx("code",{children:"setImmediate"}),"实际上是一个在事件循环的单独阶段运行的特殊计时器，它使用一个libuv API来安排回调在轮询阶段完成后执行。",e.jsx("br",{}),"通常在执行代码时，事件循环最终会进入轮询阶段。但是如果回调已使用",e.jsx("code",{children:"setImmediate"}),"调度过，并且轮询阶段变为空闲状态，继续到检查阶段。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"close callbacks(关闭的回调函数)"}),"；一些关闭的回调函数，如",e.jsx("code",{children:'socket.on("close",...)'}),e.jsx("br",{}),e.jsx("br",{}),"如果socket或处理函数突然关闭(例如socket.destroy),则",e.jsx("code",{children:"close"}),"事件将在这个阶段发出，否则通过",e.jsx("code",{children:"process.nextTick"}),"发出。"]})]})]}),e.jsx(n,{items:[{title:"Node.js",key:"intro",href:"#intro"},{title:"Node bindings",key:"bindings",href:"#bindings"},{title:"V8",key:"v8",href:"#v8"},{title:"libuv",key:"libuv",href:"#libuv"},{title:"工作流程",key:"工作流程",href:"#workflow",children:[{title:"事件循环(Event Loop)",key:"eventLoop",href:"#eventLoop"},{title:"阶段概述",key:"stage",href:"#stage"}]}]})]})}export{p as default};
