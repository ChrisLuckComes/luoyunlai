import{j as e,d as r}from"./index-a233d2e0.js";import{U as s}from"./useMarkdown-30fc6593.js";import{D as a,V as d,a as n,b as o}from"./index-a95c86d4.js";import{A as h}from"./Anchor-31b59515.js";import"./index-de0c2df5.js";function f(){const i=e.jsx(s,{markdown:a}),l=e.jsx(s,{markdown:d}),t=e.jsx(s,{markdown:n}),c=e.jsx(s,{markdown:o});return e.jsxs("article",{id:"rootArticle",className:r.article,children:[e.jsxs("main",{className:r.content,children:[e.jsx("h2",{id:"proxy",className:"font-semibold text-h2 mb-2",children:"Vue3为什么使用proxy"}),e.jsx("h3",{id:"defineProperty",className:r.articleSubTitle,children:"Object.defineProperty"}),"之前，vue使用的是",e.jsx("code",{children:"Object.defineProperty"}),"拦截对象的get,set操作。",e.jsx("div",{className:r.assist,children:"Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象"}),e.jsx("br",{}),"重点是",e.jsx("strong",{children:"对象上，属性"}),"，可以理解是针对对象上的属性做处理的。 举个栗子",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"obj 要定义属性的对象"}),e.jsx("li",{children:"Prop 要定义或修改属性的名称"}),e.jsx("li",{children:"Descriptor 要定义或修改的属性描述符"})]}),i,"vue2实现双向绑定的核心代码如下",e.jsx("div",{className:r.assist,children:"src\\core\\observer\\index.ts"}),l,e.jsx("h3",{id:"definePropertyProblem",className:r.articleSubTitle,children:"Object.defineProperty存在的问题"}),e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"对象上新增属性不能触发更新"}),e.jsx("br",{}),"因为",e.jsx("code",{children:"observer"}),"监听数据的时候，当时并没有这个属性，所以后续添加的属性不会触发更新，需要手动调用",e.jsx("code",{children:"vue.$set"}),"来新增，本质上是手动调用",e.jsx("code",{children:"defineReactive"}),e.jsx("div",{className:r.assist,children:"src\\core\\observer\\index.ts"}),c]}),e.jsxs("li",{children:[e.jsx("strong",{children:"通过索引设置数组项时不能触发更新"}),"出于数组可能长度很长的考虑，不会对数组的每一个元素进行监听。同时defineProperty也没法新增索引，所以vue选择监听原生数组的方法，涉及到push,unshift,splice等会新增索引的方法，手动触发更新。",e.jsx("div",{className:r.assist,children:"src\\core\\observer\\array.ts"}),t]})]}),e.jsx("h3",{id:"proxySummary",className:r.articleSubTitle,children:"使用proxy的原因总结"}),e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:"proxy"}),"能观察的类型更丰富"]}),e.jsxs("li",{children:[e.jsx("code",{children:"proxy"}),"劫持的是整个对象，不需要特殊处理。",e.jsx("code",{children:"Object.defineProperty"}),"监听的是属性，新增属性需要再次调用"]}),e.jsxs("li",{children:["使用",e.jsx("code",{children:"Object.defineProperty"}),"，修改原对象触发；使用",e.jsx("code",{children:"proxy"}),"必须修改代理对象触发"]})]}),e.jsx("h2",{id:"collection",className:r.articleTitle,children:"Set、Map、WeakSet、WeakMap"}),e.jsx("h3",{id:"set",className:r.articleSubTitle,children:"Set"}),"set存储任何类型的唯一值，可用于数组去重，求并集，交集，差集等场景",e.jsx("h3",{id:"weakSet",className:r.articleSubTitle,children:"WeakSet"}),e.jsx("div",{children:"它主要解决弱引用对象存储的场景，和set相比，它只能是对象的集合，不能是任意类型值。如果没有其他的对WeakSet中对象的引用，那么这些对象会被回收掉。WeakSet没有存储当前对象的列表，所以不可枚举，没有遍历方法。"}),e.jsx("div",{className:r.assist,children:"弱引用是指不能确保引用的对象不回被垃圾回收期回收的引用。就是可能在任意时间被回收"}),e.jsx("h3",{id:"map",className:r.articleSubTitle,children:"Map"}),"ES6之前，只有",e.jsx("code",{children:"Array,Object"}),"两种集合，通常使用Object模拟Map，它有如下缺陷",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"key必须是string,限制了key的数据类型"}),e.jsx("li",{children:"object没有直接的方法获取size"}),e.jsx("li",{children:"无序"})]}),e.jsx("code",{children:"Map"}),"会保留所有元素的顺序",e.jsx("h3",{id:"weakMap",className:r.articleSubTitle,children:"WeakMap"}),"跟",e.jsx("code",{children:"WeakSet"}),"一样，没有遍历方法"]}),e.jsx(h,{items:[{title:"Vue3为什么改用proxy",key:"proxy",href:"#proxy",children:[{title:"Object.defineProperty",key:"defineProperty",href:"#defineProperty"},{title:"Object.defineProperty存在的问题",key:"definePropertyProblem",href:"#definePropertyProblem"},{title:"使用proxy的原因总结",key:"proxySummary",href:"#proxySummary"}]},{title:"Set、Map、WeakSet、WeakMap",key:"collection",href:"#collection",children:[{title:"Set",key:"set",href:"#set"},{title:"WeakSet",key:"weakSet",href:"#weakSet"},{title:"Map",key:"map",href:"#map"},{title:"WeakMap",key:"weakMap",href:"#weakMap"}]}]})]})}export{f as default};
