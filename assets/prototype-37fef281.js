import{j as e,d as s,e as r}from"./index-3ba01091.js";import{U as o}from"./useMarkdown-3db75fe1.js";import{N as c}from"./NickYoung-79abff95.js";import{A as i}from"./Anchor-918d3c78.js";import"./index-5b28342b.js";const l="/luoyunlai/assets/protoDebug-0964afba.png",n="/luoyunlai/assets/protoChainTop-0eff4376.png",a="/luoyunlai/assets/protoChain-324c4a52.png",j=`\`\`\`js
function Person(name) {
    this.name = name;
    this.age = null;
  }
  
  Person.prototype.setAge = function (age) {
    this.age = age;
  };
  
  let a = new Person("lyl");
  
  console.log(a.name);
  
  a.setAge(18);
  
  console.log(a.age);
  
\`\`\``;function m(){const t=e.jsx(o,{markdown:j});return e.jsxs("article",{id:"rootArticle",className:s.article,children:[e.jsxs("main",{className:s.content,children:[e.jsx("h2",{id:"pre",className:"font-semibold text-h2 mb-2",children:"10分钟内搞懂原型和原型链"}),"又是一个小伙伴们遇到会黑人问号脸的问题",e.jsx("br",{}),e.jsx("br",{}),e.jsx(r,{src:c}),e.jsx("br",{}),"老规矩，来个栗子，debug一看便知。",e.jsx("h2",{id:"debug",className:s.articleTitle,children:"Debug"}),"代码如下：",t,"打上断点，来看一下对象",e.jsx("code",{children:"a"}),"的属性：",e.jsx("br",{}),e.jsx("br",{}),e.jsx(r,{src:l}),e.jsx("br",{}),"如图，可以看到a有属性",e.jsx("code",{children:"[[Prototype]]"}),"，是不是在哪见过这种中括号的属性啊？想起来了没，就是作用域链",e.jsx("code",{children:"[[Scope]]"}),e.jsx("br",{}),e.jsx("br",{}),"上次我们提到函数执行时，作用域链用来找变量。那这个[[Prototype]]很明显就是用来找属性的了，它是链表结构，也就是我们常说的原型链。",e.jsx("h2",{id:"diff",className:s.articleTitle,children:"对象"}),e.jsx("code",{children:"ECMA"}),"将",e.jsx("strong",{children:"对象"}),"定义为一组属性的无序集合，对象的每个属性或方法都用一个名称来标识，名称对应一个值，值可以是数据或者函数。",e.jsx("br",{}),e.jsx("br",{}),"创建对象有两种方式:",e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:["1. 使用",e.jsx("code",{children:"Object"}),"构造函数"]}),e.jsx("li",{children:"2. 对象字面量"})]}),"两者都有相同的问题，创建多个具有同样属性的对象需要编写重复代码。所以针对特定类型的对象，可以自定义构造函数用于创建。",e.jsx("h2",{id:"func",className:s.articleTitle,children:"构造函数"}),"要创建对象，应该使用new操作符，它会执行如下操作",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 创建新对象"}),e.jsxs("li",{children:["2. 新对象的[[Prototype]]赋值为构造函数的",e.jsx("code",{children:"prototype"}),"属性"]}),e.jsxs("li",{children:["3. 构造函数的",e.jsx("code",{children:"this"}),"指向新对象"]}),e.jsx("li",{children:"4. 执行构造函数"}),e.jsx("li",{children:"5. 如果构造函数返回不为空，则返回该对象；否则返回刚创建的新对象"})]}),"构造函数也是函数，没有特殊语法，区别就是调用方式不同，首字母一般是大写。任何函数用new调用就是构造函数，不用就是普通函数。",e.jsx("h2",{id:"prototype",className:s.articleTitle,children:"原型"}),"每个函数都会创建一个",e.jsx("code",{children:"prototype"}),"属性，它是一个对象，包含特定引用类型的实例共享的属性。实际上这个对象就是通过调用构造函数创建的对象的",e.jsx("strong",{children:"原型"}),e.jsx("br",{}),e.jsx("br",{}),"每当调用构造函数创建一个新实例，实例的内部[[Prototype]]的指针就会被赋值为构造函数的原型对象。 虽然js不能直接访问到[[Prototype]]，但是Chrome,Safari,Firefox浏览器会在每个对象上暴露",e.jsx("code",{children:"__proto__"}),"，通过这个属性就可以访问对象的原型，也可以使用",e.jsx("code",{children:"Object.getPrototypeOf(obj)"}),"来获取",e.jsx("br",{}),e.jsx("br",{})," 关键记住一句话：",e.jsx("strong",{children:"对象跟构造函数原型有联系，跟构造函数没有"}),"。",e.jsx("code",{children:"console.log(obj.__proto__ === Object.prototype) // true"}),e.jsx("h3",{id:"attr",className:s.articleSubTitle,children:"访问属性"}),"在通过对象访问属性时，会按照这个属性的名称开始找。首先是在对象本身开始，如果找到了就返回对应的值。如果没有找到，则会沿着",e.jsx("code",{children:"[[Prototype]]"}),"这个指针进入原型对象， 然后在原型对象上找到属性后再返回对应的值。",e.jsx("br",{}),"因此，在调用",e.jsx("code",{children:"a.setAge()"}),"时，会发生两步搜索，先问a有setAge属性吗？没有。然后继续找，再问a的原型有setAge属性吗？有。于是就返回了保存在原型上的这个函数",e.jsx("h2",{id:"protoChain",className:s.articleTitle,children:"原型链"}),"一个原型也会是另一个类型的实例，所以就构成了一个链条，如下图：",e.jsx(r,{src:a}),e.jsx("br",{}),e.jsx("br",{}),"直观视觉版，可以看到就是一个链条，顶部为",e.jsx("code",{children:"Object"}),"，因为默认情况下，所有引用类型都继承自Object，也是通过原型链实现的，任何函数的默认原型都是Object的实例：",e.jsx(r,{src:n}),"原型链扩展了上文访问属性的搜索机制，通过原型链就可以继续向上搜索原型的原型。"]}),e.jsx(i,{items:[{title:"前言",key:"pre",href:"#pre"},{title:"Debug",key:"debug",href:"#debug"},{title:"对象",key:"object",href:"#object"},{title:"构造函数",key:"func",href:"#func"},{title:"原型",key:"prototype",href:"#prototype",children:[{title:"访问属性",key:"attr",href:"#attr"}]},{title:"原型链",key:"protoChain",href:"#protoChain"}]})]})}export{m as default};
