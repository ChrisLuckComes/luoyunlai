import{j as e,d as o,e as r}from"./index-52cacda3.js";import{U as t}from"./useMarkdown-2196212a.js";import{N as c}from"./NickYoung-79abff95.js";import{A as l}from"./Anchor-4d1d2fe9.js";const n="/luoyunlai/assets/protoDebug-0964afba.png",i="/luoyunlai/assets/protoChainTop-0eff4376.png",d="/luoyunlai/assets/protoChain-324c4a52.png",j=`\`\`\`js
function Person(name) {
    this.name = name;
    this.age = null;
  }
  
  Person.prototype.setAge = function (age) {
    this.age = age;
  };
  
  let a = new Person("lyl");
  
  console.log(a.name);
  
  a.setAge(18);
  
  console.log(a.age);
  
\`\`\``;function b(){const s=e.jsx(t,{markdown:j});return e.jsxs("article",{id:"rootArticle",className:o.article,children:[e.jsxs("main",{className:o.content,children:[e.jsx("h2",{id:"pre",className:"font-semibold text-h2 mb-2",children:"10分钟内搞懂原型和原型链"}),"又是一个小伙伴们遇到会黑人问号脸的问题",e.jsx("br",{}),e.jsx("br",{}),e.jsx(r,{src:c}),e.jsx("br",{}),"老规矩，来个栗子，debug一看便知。",e.jsx("h2",{id:"debug",className:o.articleTitle,children:"Debug"}),"代码如下：",s,"打上断点，来看一下对象",e.jsx("code",{children:"a"}),"的属性：",e.jsx("br",{}),e.jsx("br",{}),e.jsx(r,{src:n}),e.jsx("br",{}),"如图，可以看到a有属性",e.jsx("code",{children:"[[Prototype]]"}),"，是不是在哪见过这种中括号的属性啊？想起来了没，就是作用域链",e.jsx("code",{children:"[[Scope]]"}),e.jsx("br",{}),e.jsx("br",{}),"上次我们提到函数执行时，作用域链用来找变量。那这个[[Prototype]]很明显就是用来找属性的了，它是链表结构，也就是我们常说的原型链。",e.jsx("h2",{id:"diff",className:o.articleTitle,children:"对象"}),e.jsx("code",{children:"ECMA"}),"将",e.jsx("strong",{children:"对象"}),"定义为一组属性的无序集合，对象的每个属性或方法都用一个名称来标识，名称对应一个值，值可以是数据或者函数。",e.jsx("br",{}),e.jsx("br",{}),"创建对象有两种方式:",e.jsxs("ul",{className:o.ul,children:[e.jsxs("li",{children:["1. 使用",e.jsx("code",{children:"Object"}),"构造函数"]}),e.jsx("li",{children:"2. 对象字面量"})]}),"两者都有相同的问题，创建多个具有同样属性的对象需要编写重复代码。所以针对特定类型的对象，可以自定义构造函数用于创建。",e.jsx("h2",{id:"func",className:o.articleTitle,children:"构造函数"}),"要创建对象，应该使用new操作符，它会执行如下操作",e.jsxs("ul",{children:[e.jsx("li",{children:"1. 创建新对象"}),e.jsxs("li",{children:["2. 新对象的[[Prototype]]赋值为构造函数的",e.jsx("code",{children:"prototype"}),"属性"]}),e.jsxs("li",{children:["3. 构造函数的",e.jsx("code",{children:"this"}),"指向新对象"]}),e.jsx("li",{children:"4. 执行构造函数"}),e.jsxs("li",{children:["5. 如果构造函数返回一个对象，则该对象将作为 ",e.jsx("code",{children:"new"})," 操作符的结果返回。否则（如果构造函数没有返回对象、返回 ",e.jsx("code",{children:"null"})," 或返回一个原始值），则新创建的对象将被返回。"]})]}),"构造函数也是函数，没有特殊语法，区别就是调用方式不同，首字母一般是大写。任何函数用new调用就是构造函数，不用就是普通函数。",e.jsx("h2",{id:"prototype",className:o.articleTitle,children:"原型"}),"每个函数都会创建一个",e.jsx("code",{children:"prototype"}),"属性，它是一个对象，包含特定引用类型的实例共享的属性。实际上这个对象就是通过调用构造函数创建的对象的",e.jsx("strong",{children:"原型"}),e.jsx("br",{}),e.jsx("br",{}),"每当调用构造函数创建一个新实例，实例的内部",e.jsx("code",{children:"[[Prototype]]"}),"的指针就会被赋值为构造函数的原型对象。 虽然JS规范中不能直接访问到",e.jsx("code",{children:"[[Prototype]]"}),"，但是大多数现代浏览器会在每个对象上暴露一个非标准的",e.jsx("code",{children:"__proto__"}),"属性，通过这个属性就可以访问对象的原型。更推荐使用ES5提供的",e.jsx("code",{children:"Object.getPrototypeOf(obj)"}),"方法来获取对象的原型。",e.jsx("br",{}),e.jsx("br",{})," 关键记住一句话：",e.jsxs("strong",{children:["实例对象通过其内部的 ",e.jsx("code",{children:"[[Prototype]]"})," (或 ",e.jsx("code",{children:"__proto__"}),") 链接到其构造函数的 ",e.jsx("code",{children:"prototype"})," 对象，而不是直接链接到构造函数本身"]}),"。 例如，对于我们之前在Debug部分提到的 ",e.jsx("code",{children:"Person"})," 构造函数和实例 ",e.jsx("code",{children:"a"})," (",e.jsx("code",{children:'let a = new Person("lyl")'}),")：",e.jsx("code",{children:"console.log(a.__proto__ === Person.prototype) // true"}),e.jsx("code",{children:"console.log(Object.getPrototypeOf(a) === Person.prototype) // true"}),e.jsx("br",{}),"而 ",e.jsx("code",{children:"Person.prototype"})," 本身也是一个对象，它的原型默认指向 ",e.jsx("code",{children:"Object.prototype"}),"：",e.jsx("code",{children:"console.log(Person.prototype.__proto__ === Object.prototype) // true"}),e.jsx("code",{children:"console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype) // true"}),e.jsx("br",{}),"对于一个通过对象字面量创建的普通对象，例如 ",e.jsxs("code",{children:["let obj = ",";"]}),"，其原型直接是 ",e.jsx("code",{children:"Object.prototype"}),"：",e.jsx("code",{children:"console.log(obj.__proto__ === Object.prototype) // true"}),e.jsx("code",{children:"console.log(Object.getPrototypeOf(obj) === Object.prototype) // true"}),e.jsx("h3",{id:"attr",className:o.articleSubTitle,children:"访问属性"}),"在通过对象访问属性时，会按照这个属性的名称开始找。首先是在对象本身开始，如果找到了就返回对应的值。如果没有找到，则会沿着",e.jsx("code",{children:"[[Prototype]]"}),"这个指针进入原型对象， 然后在原型对象上找到属性后再返回对应的值。",e.jsx("br",{}),"因此，在调用",e.jsx("code",{children:"a.setAge()"}),"时，会发生两步搜索，先问a有setAge属性吗？没有。然后继续找，再问a的原型有setAge属性吗？有。于是就返回了保存在原型上的这个函数",e.jsx("h2",{id:"protoChain",className:o.articleTitle,children:"原型链"}),"一个原型也会是另一个类型的实例，所以就构成了一个链条，如下图：",e.jsx(r,{src:d}),e.jsx("br",{}),e.jsx("br",{}),"直观视觉版，可以看到就是一个链条，顶部为",e.jsx("code",{children:"Object"}),"，因为默认情况下，所有引用类型都继承自Object，也是通过原型链实现的，任何函数的默认原型都是Object的实例：",e.jsx(r,{src:i}),e.jsx("br",{}),"原型链扩展了上文访问属性的搜索机制，通过原型链就可以继续向上搜索原型的原型。"]}),e.jsx(l,{items:[{title:"前言",key:"pre",href:"#pre"},{title:"Debug",key:"debug",href:"#debug"},{title:"对象",key:"diff",href:"#diff"},{title:"构造函数",key:"func",href:"#func"},{title:"原型",key:"prototype",href:"#prototype",children:[{title:"访问属性",key:"attr",href:"#attr"}]},{title:"原型链",key:"protoChain",href:"#protoChain"}]})]})}export{b as default};
