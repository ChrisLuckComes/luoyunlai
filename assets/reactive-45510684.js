import{j as e,d as r}from"./index-a233d2e0.js";import{j as b,k as E,l as g,m as v,n as y,M as T,o as R,p as w,q as H,r as N,R as _,s as A,t as C,u as M,v as I,w as F}from"./index-a95c86d4.js";import{U as s}from"./useMarkdown-30fc6593.js";import{A as O}from"./Anchor-31b59515.js";import"./index-de0c2df5.js";function D(){const c=e.jsx(s,{markdown:b}),l=e.jsx(s,{markdown:E}),a=e.jsx(s,{markdown:g}),t=e.jsx(s,{markdown:v}),i=e.jsx(s,{markdown:y}),d=e.jsx(s,{markdown:T}),n=e.jsx(s,{markdown:R}),x=e.jsx(s,{markdown:w}),h=e.jsx(s,{markdown:H}),j=e.jsx(s,{markdown:N}),o=e.jsx(s,{markdown:_}),m=e.jsx(s,{markdown:A}),f=e.jsx(s,{markdown:C}),u=e.jsx(s,{markdown:M}),k=e.jsx(s,{markdown:I}),p=e.jsx(s,{markdown:F});return e.jsxs("article",{id:"rootArticle",className:r.article,children:[e.jsxs("main",{className:r.content,children:[e.jsx("h2",{id:"reactive",className:"font-semibold text-h2 mb-2",children:"reactive"}),"接受一个普通对象然后返回该对象的响应式",e.jsx("code",{children:"proxy"}),e.jsx("br",{}),"Vue3中响应式数据核心是",e.jsx("code",{children:"reactive"}),"，它由",e.jsx("code",{children:"proxy"}),"+",e.jsx("code",{children:"effect"}),"组合",e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\reactive.ts"}),j,"再进入",e.jsx("code",{children:"createReactiveObject"}),a,"函数先是做了一些判断，如下情况会直接返回",e.jsx("code",{children:"target"}),e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"不是对象"}),e.jsx("li",{children:"已经是proxy或者已被观察过"}),e.jsxs("li",{children:["对象类型是否能被代理",e.jsx("br",{}),e.jsx("code",{children:"getTargetType"}),"判断是否满足如下条件",u,e.jsxs("ul",{children:[e.jsx("li",{children:"1.没有__v_skip标记"}),e.jsx("li",{children:"2.没有被冻结"}),e.jsx("li",{children:"3.在可以代理的类型case内"})]})]})]}),"最后创建proxy并返回",e.jsx("h2",{id:"ref",className:r.articleTitle,children:"ref"}),"接受一个参数值并返回一个响应式且可改变的ref对象，ref对象拥有一个指向内部值的单一属性.value ref可以看作是",e.jsx("code",{children:"reactive"})," ","的变形，用于解决值类型的数据响应，如果传入ref的是对象，会调用",e.jsx("code",{children:"reactive"}),e.jsx("br",{}),e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\ref.ts"}),f,e.jsx("br",{}),e.jsx("code",{children:"ref"}),"调用",e.jsx("code",{children:"createRef"}),"，判断value是不是ref，如果不是调用",e.jsx("code",{children:"new RefImpl"}),e.jsx("br",{}),e.jsx("br",{}),"构造函数中，如果shallow是true直接将初始值和当前值都设为value,否则调用reactive包装value",e.jsx("br",{}),e.jsx("code",{children:"RefImpl"}),"类定义了私有属性_value,_rawValue,对外提供get set来读写，所以ref需要使用.value属性操作，这样可以避免直接修改。",e.jsx("br",{}),t,e.jsx("br",{}),e.jsx("h2",{id:"baseHandlers",className:r.articleTitle,children:"baseHandlers"}),"handlers是Proxy的第二个参数，针对target具体操作同时做一些处理。",e.jsx("code",{children:"baseHandlers"}),"包含4种handler",e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\baseHandlers.ts"}),e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"mutableHandlers 可变处理"}),e.jsx("li",{children:"readonlyHandlers 只读处理"}),e.jsx("li",{children:"shallowReactiveHandlers 浅观察处理"}),e.jsx("li",{children:"shallowReadonlyHandlers 潜观察且只读处理"})]}),"其他三个handler都是",e.jsx("code",{children:"mutableHandlers"}),"的变形",e.jsx("h3",{id:"mutableHandlers",className:r.articleSubTitle,children:"mutableHandlers"}),n,e.jsx("br",{}),e.jsx("code",{id:"get",children:"get"}),d,e.jsx("code",{id:"set",children:"set"}),h,e.jsx("code",{id:"other",children:"deleteProperty has ownKeys"}),x,"其中多次出现的两个函数",e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"track"})," 依赖收集"]}),e.jsxs("li",{children:[e.jsx("code",{children:"trigger"})," 触发依赖"]})]}),"它们是",e.jsx("code",{children:"effect"}),"里的方法，effect是",e.jsx("code",{children:"reactive"}),"的核心",e.jsx("br",{}),e.jsx("h2",{id:"effect",className:r.articleTitle,children:"effect"}),"从定义看起，",e.jsx("code",{children:"effect"}),"两个参数",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"fn 回调函数"}),e.jsx("li",{children:"options 参数"})]}),e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\effect.ts"}),i,"又回到了",e.jsx("code",{children:"reactiveEffect"}),o,"构造函数调用 ",e.jsx("code",{children:"recordEffectScope"}),m,e.jsx("br",{}),"那么",e.jsx("code",{children:"effect"}),"是如何收集和触发依赖的呢？接下来就来看看",e.jsx("code",{children:"track"}),"和",e.jsx("code",{children:"trigger"}),e.jsx("h3",{id:"track",className:r.articleSubTitle,children:"track"}),k,e.jsx("h3",{id:"trigger",className:r.articleSubTitle,children:"trigger"}),p,e.jsx("br",{}),e.jsx("h2",{id:"computed",className:r.articleTitle,children:"computed"}),"传入一个getter，返回不可手动修改的ref对象",e.jsx("br",{}),"或者传入一个包含get，set函数的对象，创建一个可以手动修改的计算属性",e.jsx("br",{}),"可能会依赖其他",e.jsx("code",{children:"reactive"}),"的值，同时会延迟和缓存计算值",e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\computed.ts"}),c,"调用",e.jsx("code",{children:"ComputedRefImpl"}),l,e.jsx("h2",{id:"summary",className:r.articleTitle,children:"总结"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"ref,reactive"})," proxy监听属性get,set操作"]}),e.jsxs("li",{children:["访问属性，触发get,调用",e.jsx("code",{children:"track"}),"收集依赖"]}),e.jsxs("li",{children:["修改属性，触发set，调用",e.jsx("code",{children:"trigger"}),"effect.run"]})]})]}),e.jsx(O,{items:[{title:"reactive",key:"reactive",href:"#reactive"},{title:"ref",key:"ref",href:"#ref"},{title:"baseHandlers",key:"baseHandlers",href:"#baseHandlers",children:[{title:"mutableHandlers",key:"mutableHandlers",href:"#mutableHandlers"},{title:"get",key:"get",href:"#get"},{title:"set",key:"set",href:"#set"},{title:"deleteProperty has ownKeys",key:"other",href:"#other"}]},{title:"effect",key:"effect",href:"#effect",children:[{title:"track",key:"track",href:"#track"},{title:"trigger",key:"trigger",href:"#trigger"}]},{title:"computed",key:"computed",href:"#computed"},{title:"总结",key:"summary",href:"#summary"}]})]})}export{D as default};
