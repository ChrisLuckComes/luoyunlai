import{j as e,d as r}from"./index-d995f4f1.js";import{j as g,k as p,l as E,m as v,n as y,M as T,o as R,p as w,q as H,r as N,R as _,s as A,t as M,u as C,v as O,w as D}from"./index-e286e11f.js";import{U as s}from"./useMarkdown-9bb10794.js";import{A as I}from"./Anchor-4feb64ba.js";import"./index-fd3e1634.js";function B(){const c=e.jsx(s,{markdown:g}),l=e.jsx(s,{markdown:p}),i=e.jsx(s,{markdown:E}),t=e.jsx(s,{markdown:v}),a=e.jsx(s,{markdown:y}),d=e.jsx(s,{markdown:T}),n=e.jsx(s,{markdown:R}),x=e.jsx(s,{markdown:w}),j=e.jsx(s,{markdown:H}),h=e.jsx(s,{markdown:N}),o=e.jsx(s,{markdown:_}),f=e.jsx(s,{markdown:A}),m=e.jsx(s,{markdown:M}),u=e.jsx(s,{markdown:C}),k=e.jsx(s,{markdown:O}),b=e.jsx(s,{markdown:D});return e.jsxs("article",{id:"rootArticle",className:r.article,children:[e.jsxs("main",{className:r.content,children:[e.jsx("h2",{id:"reactive",className:"font-semibold text-h2 mb-2",children:"reactive"}),"接受一个普通对象然后返回该对象的响应式",e.jsx("code",{children:"proxy"}),e.jsx("br",{}),"Vue3中响应式数据核心是",e.jsx("code",{children:"reactive"}),"，它由",e.jsx("code",{children:"proxy"}),"+",e.jsx("code",{children:"effect"}),"组合",e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\reactive.ts"}),h,"再进入",e.jsx("code",{children:"createReactiveObject"}),i,"函数先是做了一些判断，如下情况会直接返回",e.jsx("code",{children:"target"}),e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"不是对象"}),e.jsx("li",{children:"已经是proxy或者已被观察过"}),e.jsxs("li",{children:["对象类型是否能被代理",e.jsx("br",{}),e.jsx("code",{children:"getTargetType"}),"判断是否满足如下条件",u,e.jsxs("ul",{children:[e.jsx("li",{children:"1.没有__v_skip标记"}),e.jsx("li",{children:"2.没有被冻结"}),e.jsx("li",{children:"3.在可以代理的类型case内"})]})]})]}),"最后创建proxy并返回",e.jsx("h2",{id:"ref",className:r.articleTitle,children:"ref"}),"接受一个参数值并返回一个响应式且可改变的ref对象，ref对象拥有一个指向内部值的单一属性.value ref可以看作是",e.jsx("code",{children:"reactive"})," 的变形，用于解决值类型的数据响应，如果传入ref的是对象，会调用",e.jsx("code",{children:"reactive"}),e.jsx("br",{}),e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\ref.ts"}),m,e.jsx("br",{}),e.jsx("code",{children:"ref"}),"调用",e.jsx("code",{children:"createRef"}),"，判断value是不是ref，如果不是调用",e.jsx("code",{children:"new RefImpl"}),e.jsx("br",{}),e.jsx("br",{}),"构造函数中，如果shallow是true直接将初始值和当前值都设为value,否则调用reactive包装value",e.jsx("br",{}),e.jsx("code",{children:"RefImpl"}),"类定义了私有属性_value,_rawValue,对外提供get set来读写，所以ref需要使用.value属性操作，这样可以避免直接修改。",e.jsx("br",{}),t,e.jsx("br",{}),e.jsx("h2",{id:"baseHandlers",className:r.articleTitle,children:"baseHandlers"}),"handlers是Proxy的第二个参数，针对target具体操作同时做一些处理。",e.jsx("code",{children:"baseHandlers"}),"包含4种handler",e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\baseHandlers.ts"}),e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"mutableHandlers 可变处理"}),e.jsx("li",{children:"readonlyHandlers 只读处理"}),e.jsx("li",{children:"shallowReactiveHandlers 浅观察处理"}),e.jsx("li",{children:"shallowReadonlyHandlers 潜观察且只读处理"})]}),"其他三个handler都是",e.jsx("code",{children:"mutableHandlers"}),"的变形",e.jsx("h3",{id:"mutableHandlers",className:r.articleSubTitle,children:"mutableHandlers"}),n,e.jsx("br",{}),e.jsx("code",{id:"get",children:"get"}),d,e.jsx("code",{id:"set",children:"set"}),j,e.jsx("code",{id:"other",children:"deleteProperty has ownKeys"}),x,"其中多次出现的两个函数",e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"track"})," 依赖收集"]}),e.jsxs("li",{children:[e.jsx("code",{children:"trigger"})," 触发依赖"]})]}),"它们是",e.jsx("code",{children:"effect"}),"里的方法，effect是",e.jsx("code",{children:"reactive"}),"的核心",e.jsx("br",{}),e.jsx("h2",{id:"effect",className:r.articleTitle,children:"effect"}),"从定义看起，",e.jsx("code",{children:"effect"}),"两个参数",e.jsxs("ul",{className:r.ul,children:[e.jsx("li",{children:"fn 回调函数"}),e.jsx("li",{children:"options 参数"})]}),e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\effect.ts"}),a,"又回到了",e.jsx("code",{children:"reactiveEffect"}),o,"构造函数调用 ",e.jsx("code",{children:"recordEffectScope"}),f,e.jsx("br",{}),"那么",e.jsx("code",{children:"effect"}),"是如何收集和触发依赖的呢？接下来就来看看",e.jsx("code",{children:"track"}),"和",e.jsx("code",{children:"trigger"}),e.jsx("h3",{id:"track",className:r.articleSubTitle,children:"track"}),k,e.jsx("h3",{id:"trigger",className:r.articleSubTitle,children:"trigger"}),b,e.jsx("br",{}),e.jsx("h2",{id:"computed",className:r.articleTitle,children:"computed"}),"传入一个getter，返回不可手动修改的ref对象",e.jsx("br",{}),"或者传入一个包含get，set函数的对象，创建一个可以手动修改的计算属性",e.jsx("br",{}),"可能会依赖其他",e.jsx("code",{children:"reactive"}),"的值，同时会延迟和缓存计算值",e.jsx("div",{className:r.assist,children:"packages\\reactivity\\src\\computed.ts"}),c,"调用",e.jsx("code",{children:"ComputedRefImpl"}),l,e.jsx("h2",{id:"summary",className:r.articleTitle,children:"总结"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("strong",{children:"响应式数据的创建"}),"通过",e.jsx("code",{children:"ref,reactive"}),"创建响应式变量或对象，内部创建",e.jsx("code",{children:"proxy"}),"来代理原始对象，",e.jsx("code",{children:"get"}),"拦截器执行依赖收集,",e.jsx("code",{children:"set"}),"拦截器执行依赖更新的操作"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"依赖收集"}),"在组件初始化时，组件的渲染函数会被封装成",e.jsx("code",{children:"effect"}),"副作用函数。这个副作用函数会在组件首次渲染时执行，并且在执行过程中会访问响应式数据。",e.jsx("br",{}),"此时会触发",e.jsx("code",{children:"Proxy"}),"的",e.jsx("code",{children:"get"}),"拦截器，调用",e.jsx("code",{children:"track"}),"收集依赖。",e.jsx("code",{children:"track"}),"函数会将当前正在执行的",e.jsx("code",{children:"activeEffect"}),"副作用函数与被访问的响应式数据建立关联，将其保存到一个依赖集合中。",e.jsx("br",{})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"依赖更新"}),"数据修改触发",e.jsx("code",{children:"set"}),"拦截器，调用",e.jsx("code",{children:"trigger"}),"函数遍历依赖集合中的所有副作用函数，并执行它们。如果副作用是组件渲染函数，那么就会重新渲染组件生成新的虚拟DOM树。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"虚拟DOM比较与更新"}),"重新执行渲染函数后，生成新的虚拟DOM树，与上一次渲染生成的虚拟DOM树进行比较，找出差异并更新到真实DOM上。这个过程称为",e.jsx("code",{children:"diff"}),"算法"]})]})]}),e.jsx(I,{items:[{title:"reactive",key:"reactive",href:"#reactive"},{title:"ref",key:"ref",href:"#ref"},{title:"baseHandlers",key:"baseHandlers",href:"#baseHandlers",children:[{title:"mutableHandlers",key:"mutableHandlers",href:"#mutableHandlers"},{title:"get",key:"get",href:"#get"},{title:"set",key:"set",href:"#set"},{title:"deleteProperty has ownKeys",key:"other",href:"#other"}]},{title:"effect",key:"effect",href:"#effect",children:[{title:"track",key:"track",href:"#track"},{title:"trigger",key:"trigger",href:"#trigger"}]},{title:"computed",key:"computed",href:"#computed"},{title:"总结",key:"summary",href:"#summary"}]})]})}export{B as default};
