import{j as e,d as r,e as c}from"./index-efdda179.js";import{B as k,c as g,C as F,d as W,D as N,E as C,a as T,F as S,H as P,e as O,f as w,g as E,U as R,h as L,W as U}from"./index-47083441.js";import{F as y}from"./fiber-78a128cb.js";import{U as s}from"./useMarkdown-77fc54f3.js";import{A as D}from"./Anchor-0e5acf0c.js";import"./index-b85a3ae0.js";const I="/luoyunlai/assets/beginWork-7b9f4e1d.png",M="/luoyunlai/assets/subTreeFlags-08066cbd.png",_="/luoyunlai/assets/effectList-ee8d6e89.png";function Y(){const i=e.jsx(s,{markdown:k}),d=e.jsx(s,{markdown:g}),l=e.jsx(s,{markdown:F}),n=e.jsx(s,{markdown:W}),o=e.jsx(s,{markdown:N}),t=e.jsx(s,{markdown:C}),h=e.jsx(s,{markdown:T}),a=e.jsx(s,{markdown:S}),x=e.jsx(s,{markdown:P}),j=e.jsx(s,{markdown:O}),b=e.jsx(s,{markdown:w}),m=e.jsx(s,{markdown:E}),p=e.jsx(s,{markdown:R}),f=e.jsx(s,{markdown:L}),u=e.jsx(s,{markdown:U});return e.jsxs("article",{id:"rootArticle",className:r.article,children:[e.jsxs("main",{className:r.content,children:[e.jsx("h2",{id:"flow",className:"font-semibold text-h2 mb-2",children:"Render阶段流程"}),e.jsx("code",{children:"render阶段"}),"开始于",e.jsx("code",{children:"performSyncWorkOnRoot"}),"或",e.jsx("code",{children:"performConcurrentWorkOnRoot"}),"。取决于本次更新是同步更新还是异步更新 它们会调用如下两个方法",e.jsx("div",{className:r.assist,children:"packages\\react-reconciler\\src\\ReactFiberWorkLoop.new.js"}),f,e.jsx("br",{}),u,"它们唯一的区别就是调用",e.jsx("code",{children:"shouldYield"}),"，如果当前浏览器帧没有剩余时间，",e.jsx("code",{children:"shouldYield"}),"会中止循环，直到浏览器有空闲时间后再继续遍历。",e.jsx("br",{}),e.jsx("br",{}),e.jsx("code",{children:"workInProgress"}),"代表当前已创建的",e.jsx("code",{children:"workInProgress Fiber"}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("code",{children:"performUnitOfWork"}),"会创建下一个",e.jsx("code",{children:"Fiber"}),"节点并赋值给",e.jsx("code",{children:"workInProgress"}),"，并将",e.jsx("code",{children:"workInProgress"}),"与已创建的",e.jsx("code",{children:"Fiber"}),"节点连接起来构成",e.jsx("code",{children:"Fiber树"}),e.jsx("br",{}),e.jsx("h3",{id:"traverseDown",className:r.articleSubTitle,children:"向下阶段"}),"首先从",e.jsx("code",{children:"rootFiber"}),"开始向下深度优先遍历，为遍历到的每个",e.jsx("code",{children:"Fiber节点"}),"调用",e.jsx("code",{children:"beginWork"}),e.jsx("br",{}),"该方法会根据传入的",e.jsx("code",{children:"Fiber节点"}),"创建子",e.jsx("code",{children:"Fiber节点"}),"，并将这两个",e.jsx("code",{children:"Fiber节点"}),"连接起来",e.jsx("br",{}),e.jsx("br",{}),"当遍历到叶子节点时，就会进入向上阶段",e.jsx("br",{}),e.jsx("h3",{id:"traverseUp",className:r.articleSubTitle,children:"向上阶段"}),"这个阶段会调用",e.jsx("code",{children:"completeWork"}),"处理",e.jsx("code",{children:"Fiber节点"}),"当某个",e.jsx("code",{children:"Fiber节点"}),"执行完",e.jsx("code",{children:"completeWork"}),"，如果存在兄弟节点(",e.jsx("code",{children:"fiber.sibling!==null"}),")，会进入兄弟节点的向下阶段。",e.jsx("br",{}),"如果不存在兄弟节点，会进入父节点的向上阶段。",e.jsx("br",{}),"向上和向下会交错执行直到向上回到",e.jsx("code",{children:"rootFiber"}),"，至此，",e.jsx("code",{children:"rennder"}),"阶段结束.",e.jsx("br",{}),"还是之前的栗子",h,e.jsx(c,{src:y}),e.jsx("code",{children:"render阶段"}),"会依次执行",e.jsx("div",{className:r.markdown,children:e.jsxs("ul",{children:[e.jsx("li",{children:"1. rootFiber beginWork"}),e.jsx("li",{children:"2. App Fiber beginWork"}),e.jsx("li",{children:"3. div Fiber beginWork"}),e.jsx("li",{children:'4. "i am" Fiber beginWork'}),e.jsx("li",{children:'5. "i am" Fiber completeWork'}),e.jsx("li",{children:"6. span Fiber beginWork"}),e.jsx("li",{children:"7. span Fiber completeWork"}),e.jsx("li",{children:"8. div Fiber completeWork"}),e.jsx("li",{children:"9. App Fiber completeWork"}),e.jsx("li",{children:"10. rootFiber completeWork"})]})}),"为什么span的文本节点没有begin/complete Work呢？",e.jsx("span",{className:r.assist,children:"React针对只有单一文本子节点的Fiber进行了特殊处理以优化性能"}),e.jsx("h2",{id:"beginWork",className:r.articleTitle,children:"beginWork"}),e.jsx("h3",{id:"beginWorkParams",className:r.articleSubTitle,children:"传入参数"}),d,e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:["current: 当前组件对应的",e.jsx("code",{children:"Fiber节点"}),"在上一次更新时的",e.jsx("code",{children:"Fiber节点"})]}),",即",e.jsx("code",{children:"workInProgress.alternate"}),e.jsxs("li",{children:["workInProgress: 当前组件对应的",e.jsx("code",{children:"Fiber节点"})]}),e.jsx("li",{children:"renderLanes: 优先级相关"})]}),"beginWork工作可以分为两部分",e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:"update"}),"时：如果",e.jsx("code",{children:"current"}),"存在，满足一定条件时可以复用",e.jsx("code",{children:"current"}),"节点 ，这样就可以复用current.child作为workInProgress.child，而不需要新建"]}),e.jsxs("li",{children:[e.jsx("code",{children:"mount"}),"时，除了",e.jsx("code",{children:"fiberRootNode"}),"以外，",e.jsx("code",{children:"current===null"}),"，会根据",e.jsx("code",{children:"fiber.tag"}),"来创建不同类型的子节点"]})]}),e.jsx("div",{className:r.assist,children:"packages\\react-reconciler\\src\\ReactFiberBeginWork.new.js"}),i,e.jsx("h3",{id:"update",className:r.articleSubTitle,children:"update时"}),"如下情况",e.jsx("code",{children:"didReceiveUpdate === false"}),"，也就是可以复用前一次更新的子节点",e.jsxs("ul",{children:[e.jsxs("li",{children:["1."," ",e.jsx("code",{children:"oldProps === newProps && workInProgress.type === current.type"}),"，即props跟fiber.type不变"]}),e.jsxs("li",{children:["2. ",e.jsx("code",{children:"!hasScheduledUpdateOrContext"}),"，即当前节点优先级不够",e.jsx("br",{}),"调用",e.jsx("code",{children:"checkScheduledUpdateOrContext"}),"，检查当前节点优先级。如果优先级不够",e.jsx("code",{children:"hasScheduledUpdateOrContext"}),"为false",l]})]}),e.jsx("h3",{id:"update",className:r.articleSubTitle,children:"mount时"}),"当不满足优化条件时，就要新建子节点了。根据",e.jsx("code",{children:"fiber.tag"}),"不同，进入不同类型的",e.jsx("code",{children:"Fiber"}),"的创建逻辑",e.jsx("div",{className:r.assist,children:"tag对应的类型在packages\\react-devtools-shared\\src\\backend\\renderer.js可以看到，个版本有略微区别"}),"对于常见的组件类型，最终会进入",e.jsx("code",{children:"reconcileChildren"}),"方法",e.jsx("h3",{id:"reconcileChildren",className:r.articleSubTitle,children:"reconcileChildren"}),"它是",e.jsx("code",{children:"Reconciler"}),"的核心部分",e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:["对于",e.jsx("code",{children:"mount"}),"的组件，它会创建新的",e.jsx("code",{children:"子fiber节点"})]}),e.jsxs("li",{children:["对于",e.jsx("code",{children:"update"}),"的组件，它会将当前组件与该组件上次更新对应的",e.jsx("code",{children:"Fiber节点"}),"比较（",e.jsx("code",{children:"Diff"}),"），将比较的结果生成新的节点"]})]}),m,"从代码可以看出，和",e.jsx("code",{children:"beginWork"}),"一样，它也是通过",e.jsx("code",{children:"current===null"}),"来区分",e.jsx("code",{children:"mount"}),"和",e.jsx("code",{children:"update"}),e.jsx("br",{}),e.jsx("br",{}),"最后会生成新的子",e.jsx("code",{children:"Fiber节点"}),"并赋值给",e.jsx("code",{children:"workInProgress.child"}),"，作为本次",e.jsx("code",{children:"beginWork"}),"返回值，并作为下次",e.jsx("code",{children:"performUnitOfWork"}),"执行时",e.jsx("code",{children:"workInProgress"}),"的传参",e.jsxs("div",{className:r.assist,children:[e.jsx("code",{children:"mountChildFibers"}),"和",e.jsx("code",{children:"reconcileChildFibers"}),"逻辑基本一致，区别是reconcileChildFibers会为生成的",e.jsx("code",{children:"Fiber节点"}),"带上",e.jsx("code",{children:"effectTag"})]}),e.jsx("h3",{id:"effectTag",className:r.articleSubTitle,children:"effectTag"}),"DOM操作的具体类型就保存在",e.jsx("code",{children:"fiber.effectTag"}),"中",a,e.jsxs("div",{className:r.assist,children:["通过二进制表示可以更方便的用位操作为",e.jsx("code",{children:"fiber.effectTag"}),"来赋值"]}),"多个",e.jsx("code",{children:"effect"}),"如果要通知",e.jsx("code",{children:"renderer"}),"将",e.jsx("code",{children:"fiber节点"}),"对应的DOM插入页面中，需要满足两个条件",e.jsxs("ul",{children:[e.jsxs("li",{children:["1. ",e.jsx("code",{children:"fiber.stateNode"}),"存在，即DOM节点不为空"]}),e.jsxs("li",{children:["2. ",e.jsx("code",{children:"(fiber.effectTag & Placement)!==0"}),"，即节点存在修改"]})]}),e.jsxs("div",{className:r.assist,children:[e.jsx("code",{children:"mount"}),"时，只有",e.jsx("code",{children:"rootFiber"}),"会赋值",e.jsx("code",{children:"Placement effectTag"}),"，这样在首屏渲染",e.jsx("code",{children:"commit阶段"}),"只会执行一次插入操作"]}),e.jsx("br",{}),e.jsx("strong",{children:"beginWork流程图"}),e.jsx(c,{src:I}),e.jsx("h2",{id:"completeWork",className:r.articleTitle,children:"completeWork"}),"类似",e.jsx("code",{children:"beginWork"}),"，",e.jsx("code",{children:"completeWork"}),"也是根据不同的",e.jsx("code",{children:"fiber.tag"}),"调用不同的处理逻辑，以渲染页面必须的",e.jsx("code",{children:"HostComponent"}),"（即原生DOM组件对应的fiber节点）为例。",n,e.jsx("h3",{id:"hostComponent",className:r.articleSubTitle,children:"HostComponent"}),"和",e.jsx("code",{children:"beginWork"}),"一样，根据",e.jsx("code",{children:"current === null"}),"来判断是mount还是update",e.jsx("br",{}),"同时针对",e.jsx("code",{children:"HostComponent"}),"，判断",e.jsx("code",{children:"update"}),"时还要考虑",e.jsx("code",{children:"workInProgress.stateNode!==null"}),"，也就是该",e.jsx("code",{children:"fiber节点"}),"是否存在对应的DOM节点",x,e.jsx("h3",{id:"hostUpdate",className:r.articleSubTitle,children:"update时"}),"当",e.jsx("code",{children:"update"}),"时，",e.jsx("code",{children:"Fiber节点"}),"已经存在对应DOM节点，不需要生成，需要做的是处理",e.jsx("code",{children:"props"}),e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:[e.jsx("code",{children:"onClick"}),e.jsx("code",{children:"onChange"}),"等回调函数的注册"]}),e.jsxs("li",{children:["处理 ",e.jsx("code",{children:"style prop"})]}),e.jsxs("li",{children:["处理 ",e.jsx("code",{children:"DANGEROUSLY_SET_INNER_HTML prop"})]}),e.jsxs("li",{children:["处理 ",e.jsx("code",{children:"children prop"})]})]}),"最主要的逻辑就是调用了",e.jsx("code",{children:"updateHostComponent"}),j,e.jsx("code",{children:"updateHostComponent"}),"将props处理完后，赋值给",e.jsx("code",{children:"workInProgress.updateQueue"}),"，最终会在",e.jsx("code",{children:"commit阶段"}),"被渲染到页面上",p,e.jsx("code",{children:"uploadPayload"}),"是数组，它的偶数索引的值为变化的",e.jsx("code",{children:"prop key"}),"，奇数索引的值为变化的",e.jsx("code",{children:"prop value"}),o,e.jsx("h3",{id:"hostMount",className:r.articleSubTitle,children:"mount时"}),e.jsx("code",{children:"mount"}),"的主要逻辑：",e.jsxs("ul",{className:r.ul,children:[e.jsxs("li",{children:["为",e.jsx("code",{children:"Fiber节点"}),"生成了对应的DOM节点"]}),e.jsx("li",{children:"将子孙DOM节点插入刚生成的DOM节点中"}),e.jsxs("li",{children:[e.jsx("code",{children:"跟updateHostComponent"}),"类似的处理props过程"]})]}),"每次向上阶段都会调用",e.jsx("code",{children:"appendAllChildren"}),"插入子孙节点至当前生成的DOM节点下，那么到顶部",e.jsx("code",{children:"rootFiber时"}),"，DOM树就构建完成了。",b,e.jsx("h3",{id:"effectList",className:r.articleSubTitle,children:"effectList"}),e.jsx("code",{children:"commit阶段"}),"需要找到所有有",e.jsx("code",{children:"effectTag"}),"的",e.jsx("code",{children:"Fiber节点"}),"并依次执行对应操作，难道还要再遍历一次",e.jsx("code",{children:"Fiber树"}),"？",e.jsx("br",{}),e.jsx("br",{}),"为了解决这个问题，在",e.jsx("code",{children:"completeWork"}),"的上层函数",e.jsx("code",{children:"completeUnitOfWork"}),"中，每个执行完的",e.jsx("code",{children:"completeWork"}),"且存在",e.jsx("code",{children:"effectTag"}),"的",e.jsx("code",{children:"Fiber节点"}),"会被保存在",e.jsx("code",{children:"effectList"}),"这个单向链表中。",e.jsx("br",{}),e.jsx("br",{}),e.jsx("code",{children:"effectList"}),"第一个节点保存在",e.jsx("code",{children:"fiber.firstEffect"}),"，最后一个节点保存在",e.jsx("code",{children:"fiber.lastEffect"}),e.jsx("br",{}),e.jsx("br",{}),"类似于",e.jsx("code",{children:"appendAllChildren"}),"，在向上阶段，所有有",e.jsx("code",{children:"effectTag"}),"的节点都会被追加在effectList中，最终形成一条以",e.jsx("code",{children:"rootFiber.firstEffect"}),"为起点的单向链表。",t,"在",e.jsx("code",{children:"commit阶段"}),"只需要遍历",e.jsx("code",{children:"effectList"}),"就能执行所有",e.jsx("code",{children:"effect"}),"了",e.jsx(c,{src:_}),"但是从react16.14开始，effectList被重构了，改用",e.jsx("strong",{children:"SubtreeFlags"}),e.jsx("h3",{id:"SubtreeFlags",className:r.articleSubTitle,children:"SubtreeFlags"}),"重构之后，会将子节点的副作用冒泡到父节点的",e.jsx("code",{children:"SubTreeFlags"}),"属性",e.jsx(c,{src:M}),e.jsxs("ul",{children:[e.jsx("li",{children:"1.B的副作用是Passive，冒泡到A，A.SubtreeFlags包含Passive"}),e.jsx("li",{children:"2.E的副作用是Placement，冒泡到D，D.SubtreeFlags包含Placement"}),e.jsx("li",{children:"3.D冒泡到C,C.SubtreeFlags包含Placement"}),e.jsx("li",{children:"4.C的副作用为Update，C.SubtreeFlags包含Placement，C冒泡到A"}),e.jsx("li",{children:"5.最终A.SubtreeFlags包含Passive,Placement,Update"})]}),"在",e.jsx("code",{children:"commit阶段"}),"，再根据",e.jsx("code",{children:"SubtreeFlags"}),"一层层查找有副作用的节点并执行对应操作。可见这种操作需要遍历树，效率低于遍历链表，为什么要重构呢？",e.jsx("h3",{id:"Suspense",className:r.articleSubTitle,children:"Suspense"}),"根据",e.jsx("code",{children:"Suspense"}),"的理念，如果子孙组件有异步加载的内容，只会先渲染fallback。为了实现这一点，需要改变commit阶段遍历的方式，所以重构为subtreeFlags。"]}),e.jsx(D,{items:[{title:"Render阶段流程",key:"flow",href:"#flow",children:[{title:"向下阶段",key:"traverseDown",href:"#traverseDown"},{title:"向上阶段",key:"traverseUp",href:"#traverseUp"}]},{title:"beginWork",key:"beginWork",href:"#beginWork",children:[{title:"传入参数",key:"beginWorkParams",href:"#beginWorkParams"},{title:"update时",key:"update",href:"#update"},{title:"mount时",key:"mount",href:"#mount"},{title:"reconcileChildren",key:"reconcileChildren",href:"#reconcileChildren"},{title:"effectTag",key:"effectTag",href:"#effectTag"}]},{title:"completeWork",key:"completeWork",href:"#completeWork",children:[{title:"HostComponent",key:"hostComponent",href:"#hostComponent"},{title:"update时",key:"hostUpdate",href:"#hostUpdate"},{title:"mount时",key:"hostMount",href:"#hostMount"},{title:"effectList",key:"effectList",href:"#effectList"},{title:"SubtreeFlags",key:"SubtreeFlags",href:"#SubtreeFlags"},{title:"Suspense",key:"Suspense",href:"#Suspense"}]}]})]})}export{Y as default};
