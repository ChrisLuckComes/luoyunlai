import{j as e,d as s,e as r}from"./index-298bb257.js";import{V as i}from"./index-44434083.js";import{U as l}from"./useMarkdown-3461f6cc.js";import{A as t}from"./Anchor-c8fc4162.js";import"./index-6c3c40ca.js";const c="/luoyunlai/assets/vite-51249ca9.png",a="/luoyunlai/assets/vite-adv-1-a81c93b3.png",n="/luoyunlai/assets/vite-adv-2-26360cd6.png",d="/luoyunlai/assets/vite-adv-3-fe78130a.png",x="/luoyunlai/assets/max-age-1cf213af.png",j="/luoyunlai/assets/vite-deps-998aaf74.png",o="/luoyunlai/assets/vite-resource-85e66b4b.png",h=[{key:"h1",href:"#h1",title:"Vite"},{key:"1",href:"#front",title:"前言"},{key:"2",href:"#begin",title:"优点",children:[{key:"3",href:"#no-build",title:"无需打包"},{key:"4",href:"#hmr",title:"热重载(HMR)"}]},{key:"5",href:"#move",title:"迁移流程"},{key:"6",href:"#end",title:"技术选型",children:[{key:"7",href:"#rollup",title:"Rollup"},{key:"8",href:"#webpack",title:"Webpack"},{key:"9",href:"#vite",title:"Vite"},{key:"10",href:"#turbopack",title:"Turbopack"}]}];function k(){return e.jsxs("article",{id:"rootArticle",className:s.article,children:[e.jsxs("main",{className:s.content,children:[e.jsxs("h1",{id:"h1",className:s.pageTitle,children:["2022年还在用webpack?快上",e.jsx("a",{className:"text-blue",target:"_blank",rel:"noreferrer",href:"https://cn.vitejs.dev/",children:"Vite！"})]}),e.jsx("br",{}),e.jsx(r,{src:c,alt:"VITE",width:320,height:320}),e.jsx("h2",{id:"front",className:s.articleTitle,children:"前言"}),e.jsxs("p",{children:["本仓库最开始是由 ",e.jsx("code",{children:"create-react-app"})," ","创建，其中使用了webpack，关于webpack我有几点想吐槽"]}),e.jsxs("ul",{className:s.ul,children:[e.jsx("li",{children:"1.热替换速度慢，写完几行代码随手保存想看看效果，需要等个几秒才能看到。"}),e.jsx("li",{children:"2.工程规模变大后，启动速度显著变慢。"}),e.jsx("li",{children:"3.配置大而复杂，不用vue-cli/umi/creatReactApp这种集大成者高低也得来个几十行代码才能达到最佳状态"})]}),e.jsx("h2",{id:"begin",className:s.articleTitle,children:"优点"}),e.jsx("p",{children:"所以至少在本地开发阶段或者仅面向现代浏览器的工程，可以大胆使用vite来加速。那么它为什么这么快呢？主要有以下两方面原因"}),e.jsxs("ul",{className:`${s.ul} list-none`,children:[e.jsxs("li",{children:[e.jsx(r,{src:a,alt:"adv1"}),e.jsxs("div",{className:"pl-10",children:[e.jsx("br",{}),e.jsx("strong",{id:"no-build",children:"无需打包"}),"：准确的说是不用js写的打包器全量打包🤪 ",e.jsx("br",{}),e.jsx("br",{}),"1. vite会直接启动服务，并且进行预构建依赖。具体表现为对代码进行导入分析，使用",e.jsx("strong",{children:"esbuild"}),"将CJS或UMD依赖全部转换为ESM缓存到node_modules/.vite/deps目录下，后续直接从缓存获取。",e.jsx(r,{src:j,alt:"deps"}),e.jsx("br",{}),"esbuild是用go编写的，速度比js快10-100倍，因为go对多线程的支持比js好，支持共享内存（尽量复用AST），而且esbuild所有代码都是自行编写。js设计存在多线程/编译方面的缺陷。",e.jsx("br",{}),"vite提供的是ESM的源码，利用了浏览器对ESM的支持，将部分打包程序的工作交给了浏览器，对于ESM不需要类似于webpack的胶水代码。并且vite给不常变化的依赖请求加上了长期强缓存。",e.jsx(r,{src:x,alt:"max-age"}),e.jsx("br",{}),e.jsx("br",{}),"而webpack需要全量打包，并且在构建依赖时需要经过多个loader进行字符串的处理，尤其是babel-loader涉及到多次字符串AST互转的操作。Webpack 打包时间 = parse string * n + transform * n + parse to AST + compress",e.jsx("br",{})," ",e.jsx("br",{})," 2. 启动服务后，根据路由，通过http请求来获取文件和加载所需模块。（如果模块过多会受浏览器http最大并行数限制,vite首次启动慢其中之一是这个原因）下图是本路由的资源列表",e.jsx("br",{}),"可以看出vite对于资源处理的大体逻辑， index.html => 入口ESM index.tsx => index.tsx中导入的其他模块",e.jsx(r,{src:o,alt:"resource"})]})]}),e.jsxs("li",{children:[e.jsx("br",{}),e.jsx("br",{}),e.jsx(r,{src:n,alt:"adv2"}),e.jsx("br",{}),e.jsx("strong",{id:"hmr",children:"热重载(HMR)"}),"  vite明显快于webpack，这个跟它们各自的实现方式有关。",e.jsx("br",{}),e.jsx("br",{}),"Webpack-dev-server实现hmr的方式是监听到变化后，通过websocket服务主动推送，页面需要刷新。而vite只需要重新请求变化的资源即可"]}),e.jsxs("li",{children:[e.jsx("br",{}),e.jsx("br",{}),e.jsx(r,{src:d,alt:"adv3"}),e.jsx("br",{}),"vite build使用",e.jsx("strong",{children:"rollup"}),",rollup产出的包体积天然比webpack的要小，原生支持ESM非常适合组件库的开发，而webpack需要注入额外胶水代码，天然有体积上的劣势。"]})]}),e.jsx("h2",{id:"move",className:s.articleTitle,children:"迁移流程"}),e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:["从create-react-app迁移",e.jsx("br",{}),e.jsx("br",{}),e.jsxs("p",{children:[e.jsx("code",{children:"pnpm add -D vite vite-tsconfig-paths"}),e.jsx("br",{}),e.jsx("br",{}),"然后将public/index.html移动到根目录下，去掉%PUBLIC_URL%，修改script ",e.jsx("code",{children:'<script type="module" src="/src/index.tsx"><\/script>'}),e.jsx("br",{}),e.jsx("br",{}),"修改package.json的start和build命令",e.jsx("br",{}),e.jsx("br",{}),e.jsxs("code",{children:['"start": "vite",',e.jsx("br",{}),'"build": "vite build"']}),e.jsx("br",{}),e.jsx("br",{}),"新增 ",e.jsx("code",{children:"vite.config.ts"}),e.jsx(l,{markdown:i}),e.jsx("br",{}),"大功告成，可以pnpm start启动了，最后移除react-scripts ",e.jsx("code",{children:"pnpm remove react-scripts"})]})]}),e.jsx("li",{children:"umi4天然支持"})]}),e.jsx("h2",{id:"end",className:s.articleTitle,children:"技术选型"}),"可以看出本文重复最多的单词就是ESM，vite的核心理念就在于此，充分的利用现代浏览器原生支持ESM。",e.jsx("br",{}),e.jsxs("ul",{className:s.ul,children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Rollup"}),"更适合打包组件库/插件(library)。它基于ESM打包，生成的文件更小，支持tree-shaking，但是不支持代码分割。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Webpack"}),"更适合打包项目，它支持代码分割，devServer的热更新，以及各种loader和plugin来处理各种文件。但是它的产物会注入很多胶水代码，导致体积增加。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Vite"}),"更适合现代Web应用的开发(支持ESM)，追求开发效率和性能优化的可以选择Vite。如果项目需要一定兼容性，不太适合用于生产打包，当然也有插件支持。"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Turbopack"}),"很新，很快，使用Rust编写，但是它处于alpha阶段，未来等稳定了再考虑。"]})]})]}),e.jsx(t,{items:h})]})}export{k as default};
